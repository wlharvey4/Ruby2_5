This is Ruby2_5.info, produced by makeinfo version 6.5 from
Ruby2_5.texi.

Copyright (C) 2018
wlharvey4
All Rights Reserved.

   The Ruby2.5 Information and Documentation program is copyright (C)
2018 by wlharvey4.  It is published under the conditions of the GNU
General Public License, version 3.


   This is Edition 0.2a of 'Ruby 2.5 Information and Documentation'.


File: Ruby2_5.info,  Node: Top,  Next: Preface,  Up: (dir)

General Introduction
********************

This file documents Ruby 2.5, <https://www.ruby-lang.org>

   Copyright (C) 2018
wlharvey4
All Rights Reserved.

   The Ruby2.5 Information and Documentation program is copyright (C)
2018 by wlharvey4.  It is published under the conditions of the GNU
General Public License, version 3.


   This is Edition 0.2a of 'Ruby 2.5 Information and Documentation'.

* Menu:

* Preface::
* Introduction::
* Documentation::
* The Makefile::
* Code Chunk Summaries::
* Bibliography::
* Concept Index::

 -- The Detailed Node Listing --

Preface

* Audience::
* Overview::
* Conventions::
* Acknowledgements::

Documentation

* Installing Ruby::
* Developing Ruby::
* Getting Started::
* Manuals::
* Reference Documentation::
* Editors and IDEs::
* Further Reading::

Installation Methods

* Package Management Systems::
* Installers::
* Managers::
* Building From Source::

Package Management Systems

* Homebrew (OS X)::

Installers

* ruby-build::
* ruby-install::

Managers

* chruby::
* rbenv::
* RVM (``Ruby Version Manager'')::
* uru::

Building From Source

* Releases Page::
* Branches Page::
* Issue Tracking::

Getting Started

* Try Ruby!::
* Official FAQ::
* Ruby Koans::
* Why’s (Poignant) Guide to Ruby::
* Ruby in Twenty Minutes::
* Ruby from Other Languages::
* Important Language Features::
* Learning Ruby::
* Ruby Essentials::
* Learn to Program::

Official FAQ

* FAQ Iterators::
* FAQ Syntax::
* FAQ Methods::
* FAQ Classes and Modules::
* FAQ Built-In Libraries::
* FAQ Extension Library::
* FAQ Other Features::

Ruby in Twenty Minutes

* Interactive Ruby::
* Defining Methods::
* Altering Classes::
* Large Class Definition::
* Run MegaGreeter::

Ruby from Other Languages

* To Ruby From C and C++::
* To Ruby From Java::
* To Ruby From Perl::
* To Ruby From PHP::
* To Ruby From Python::

Important Language Features

* Pointers on Iteration::
* Everything has a value::
* Symbols are not lightweight Strings::
* Everything is an Object::
* Variable Constants::
* Naming conventions::
* Keyword arguments::
* The universal truth::
* Access modifiers are Methods::
* Method access::
* Classes are open::
* Funny method names::
* Singleton methods::
* Missing methods::
* Message passing --- not function calls::
* Blocks are Objects::
* Operators are syntactic sugar::

Manuals

* Ruby User's Guide::
* Programming Ruby::

Ruby User's Guide

* What Is Ruby?::
* Simple Examples::

The Makefile

* Makefile Variable Definitions::
* Makefile Default Rule::
* Makefile TWJR Rules::
* Makefile Clean Rules::

Code Chunk Summaries

* File Definitions::
* Code Chunk Definitions::
* Code Chunk References::



File: Ruby2_5.info,  Node: Preface,  Next: Introduction,  Prev: Top,  Up: Top

Preface
*******

Text here.

* Menu:

* Audience::
* Overview::
* Conventions::
* Acknowledgements::


File: Ruby2_5.info,  Node: Audience,  Next: Overview,  Up: Preface

Intended Audience
=================

Text here.


File: Ruby2_5.info,  Node: Overview,  Next: Conventions,  Prev: Audience,  Up: Preface

What Is Covered
===============

Text and chapter by chapter description here.


File: Ruby2_5.info,  Node: Conventions,  Next: Acknowledgements,  Prev: Overview,  Up: Preface

Typographical Conventions
=========================

This Info file is written in an enhanced version of Texinfo
(http://www.gnu.org/software/texinfo/), the GNU documentation
formatting language.  A single Texinfo source file is used to produce
both the printed and online versions of a program's documentation.

   Examples you would type at the command-line are preceded by the
common shell primary and secondary prompts, '$' and '>'.  Input that
you type is shown 'like this'.  Output from the command is preceded by
the glyph "-|".  This typically represents the command's standard
output.  Error messages, and other output on the command's standard
error, are preceded by the glyph "error->".  For example:

     $ echo hi on stdout
     -| hi on stdout
     $ echo hello on stderr 1>&2
     error-> hello on stderr


File: Ruby2_5.info,  Node: Acknowledgements,  Prev: Conventions,  Up: Preface

Acknowledgements
================


File: Ruby2_5.info,  Node: Introduction,  Next: Documentation,  Prev: Preface,  Up: Top

1 Introduction
**************

Ruby is ...

   A dynamic, open source programming language with a focus on
simplicity and productivity.  It has an elegant syntax that is natural
to read and easy to write.


File: Ruby2_5.info,  Node: Documentation,  Next: The Makefile,  Prev: Introduction,  Up: Top

2 Documentation
***************

Here you will find pointers to manuals, tutorials and references that
will come in handy when you feel like coding in Ruby.

* Menu:

* Installing Ruby::
* Developing Ruby::
* Getting Started::
* Manuals::
* Reference Documentation::
* Editors and IDEs::
* Further Reading::


File: Ruby2_5.info,  Node: Installing Ruby,  Next: Developing Ruby,  Up: Documentation

2.1 Installing Ruby
===================

Installation Methods
--------------------

There are several ways to install Ruby:

   * Package Manager: When you are on a UNIX-like operating system,
     using your system’s package manager is the easiest way of getting
     started.  However, the packaged Ruby version usually is not the
     newest one.
   * Installers: can be used to install a specific or multiple Ruby
     versions.  There is also an installer for Windows.
   * Managers help you to switch between multiple Ruby installations
     on your system.
   * Source: And finally, you can also build Ruby from source.

   The following overview lists available installation methods for
different needs and platforms.

* Menu:

* Package Management Systems::
* Installers::
* Managers::
* Building From Source::


File: Ruby2_5.info,  Node: Package Management Systems,  Next: Installers,  Up: Installing Ruby

2.1.1 Package Management Systems
--------------------------------

If you cannot compile your own Ruby, and you do not want to use a
third-party tool, you can use your system’s package manager to install
Ruby.

   Certain members in the Ruby community feel very strongly that you
should never use a package manager to install Ruby and that you should
use tools instead.  While the full list of pros and cons is outside of
the scope of this page, the most basic reason is that most package
managers have older versions of Ruby in their official repositories.
If you would like to use the newest Ruby, make sure you use the
correct package name, or use the tools described further below
instead.

* Menu:

* Homebrew (OS X)::


File: Ruby2_5.info,  Node: Homebrew (OS X),  Up: Package Management Systems

2.1.1.1 Homebrew (OS X)
.......................

Homebrew (http://brew.sh/)

   On macOS (High) Sierra and OS X El Capitan, Ruby 2.0 is included.

   Many people on OS X use Homebrew as a package manager.  It is
really easy to get a newer version of Ruby using Homebrew:

     $ brew install ruby

   This should install the latest Ruby version.


File: Ruby2_5.info,  Node: Installers,  Next: Managers,  Prev: Package Management Systems,  Up: Installing Ruby

2.1.2 Installers
----------------

If the version of Ruby provided by your system or package manager is
out of date, a newer one can be installed using a third-party
installer.  Some of them also allow you to install multiple versions
on the same system; associated managers can help to switch between the
different Rubies.  If you are planning to use RVM as a version manager
you do not need a separate installer, it comes with its own.

* Menu:

* ruby-build::
* ruby-install::


File: Ruby2_5.info,  Node: ruby-build,  Next: ruby-install,  Up: Installers

2.1.2.1 'ruby-build'
....................

'ruby-build' (https://github.com/rbenv/ruby-build#readme)

   'rbenv'
(https://www.ruby-lang.org/en/documentation/installation/#rbenv)

   'ruby-build' is a plugin for 'rbenv' (*note rbenv:: that allows you
to compile and install different versions of Ruby into arbitrary
directories.  'ruby-build' can also be used as a standalone program
without 'rbenv'.  It is available for OS X, Linux, and other UNIX-like
operating systems.


File: Ruby2_5.info,  Node: ruby-install,  Prev: ruby-build,  Up: Installers

2.1.2.2 'ruby-install'
......................

'ruby-install' version manager 'chruby' version switcher

   'ruby-install' (https://github.com/postmodern/ruby-install#readme)

   'chruby'
(https://www.ruby-lang.org/en/documentation/installation/#chruby)

   'ruby-install' allows you to compile and install different versions
of Ruby into arbitrary directories.  There is also a sibling, 'chruby'
(*note chruby::), which handles switching between Ruby versions.  It
is available for OS X, Linux, and other UNIX-like operating systems.


File: Ruby2_5.info,  Node: Managers,  Next: Building From Source,  Prev: Installers,  Up: Installing Ruby

2.1.3 Managers
--------------

Many Rubyists use Ruby managers to manage multiple Rubies.  They
confer various advantages but are not officially supported.  Their
respective communities are very helpful, however.

* Menu:

* chruby::
* rbenv::
* RVM (``Ruby Version Manager'')::
* uru::


File: Ruby2_5.info,  Node: chruby,  Next: rbenv,  Up: Managers

2.1.3.1 chruby
..............

'chruby' allows you to switch between multiple Rubies.  'chruby' can
manage Rubies installed by 'ruby-install' (*note ruby-install::) or
even built from source.


File: Ruby2_5.info,  Node: rbenv,  Next: RVM (``Ruby Version Manager''),  Prev: chruby,  Up: Managers

2.1.3.2 'rbenv'
...............

'rbenv' (https://github.com/rbenv/rbenv#readme)

   'ruby-build'
(https://www.ruby-lang.org/en/documentation/installation/#ruby-build)

   'rbenv' allows you to manage multiple installations of Ruby.  It
does not support installing Ruby, but there is a popular plugin named
'ruby-build' (*note ruby-build::) to install Ruby.  Both tools are
available for OS X, Linux, or other UNIX-like operating systems.


File: Ruby2_5.info,  Node: RVM (``Ruby Version Manager''),  Next: uru,  Prev: rbenv,  Up: Managers

2.1.3.3 RVM ("Ruby Version Manager")
....................................

RVM (http://rvm.io/)

   RVM allows you to install and manage multiple installations of Ruby
on your system.  It can also manage different gemsets.  It is
available for OS X, Linux, or other UNIX-like operating systems.


File: Ruby2_5.info,  Node: uru,  Prev: RVM (``Ruby Version Manager''),  Up: Managers

2.1.3.4 'uru'
.............

Uru (https://bitbucket.org/jonforums/uru)

   Uru is a lightweight, multi-platform command line tool that helps
you to use multiple Rubies on OS X, Linux, or Windows systems.


File: Ruby2_5.info,  Node: Building From Source,  Prev: Managers,  Up: Installing Ruby

2.1.4 Building From Source
--------------------------

Ruby 2.5.1 (https://www.ruby-lang.org/en/downloads/)

   Ruby Github (https://github.com/ruby/ruby)

   Of course, you can install Ruby from source.  Download and unpack a
tarball, then just do this:

     $ ./configure
     $ make
     $ sudo make install

   By default, this will install Ruby into '/usr/local'.  To change,
pass the '--prefix=DIR' option to the './configure' script.

   Using the third-party tools or package managers might be a better
idea, though, because the installed Ruby won’t be managed by any
tools.

   Installing from the source code is a great solution for when you
are comfortable enough with your platform and perhaps need specific
settings for your environment.  It’s also a good solution in the event
that there are no other premade packages for your platform.

* Menu:

* Releases Page::
* Branches Page::
* Issue Tracking::


File: Ruby2_5.info,  Node: Releases Page,  Next: Branches Page,  Up: Building From Source

2.1.4.1 Releases Page
.....................

Releases Page (https://www.ruby-lang.org/en/downloads/releases/)

   For more information about specific releases, particularly older
releases or previews, see the Releases page.

   This page lists individual Ruby releases.

Ruby 2.5.1 Released
...................

ruby-2.1.5.tar.gz
(https://cache.ruby-lang.org/pub/ruby/2.5/ruby-2.5.1.tar.gz)

   Posted by naruse on 28 Mar 2018

   This release includes some bug fixes and some security fixes.

   * CVE-2017-17742: HTTP response splitting in WEBrick
   * CVE-2018-6914: Unintentional file and directory creation with
     directory traversal in tempfile and tmpdir
   * CVE-2018-8777: DoS by large request in WEBrick
   * CVE-2018-8778: Buffer under-read in String#unpack
   * CVE-2018-8779: Unintentional socket creation by poisoned NUL byte
     in UNIXServer and UNIXSocket
   * CVE-2018-8780: Unintentional directory traversal by poisoned NUL
     byte in Dir
   * Multiple vulnerabilities in RubyGems


File: Ruby2_5.info,  Node: Branches Page,  Next: Issue Tracking,  Prev: Releases Page,  Up: Building From Source

2.1.4.2 Branches Page
.....................

Branches Page (https://www.ruby-lang.org/en/downloads/branches/)

   Information about the current maintenance status of the various
Ruby branches can be found on the Branches page.

   This page lists the current maintenance status of the various Ruby
branches.  This is a preliminary list of Ruby branches and their
maintenance status.  The shown dates are inferred from the English
versions of release posts or EOL announcements.

   The Ruby branches or release series are categorized below into the
following phases:

   * normal maintenance (bug fix): Branch receives general bug fixes
     and security fixes.
   * security maintenance (security fix): Only security fixes are
     backported to this branch.
   * eol (end-of-life): Branch is not supported by the ruby-core team
     any longer and does not receive any fixes.  No further patch
     release will be released.
   * preview: Only previews or release candidates have been released
     for this branch so far.

Ruby 2.6
........

<https://cache.ruby-lang.org/pub/ruby/2.6/ruby-2.6.0-preview2.tar.gz>

ruby-2.6.0-preview2
status: preview
release date:

Ruby 2.5
........

<https://cache.ruby-lang.org/pub/ruby/2.5/ruby-2.5.1.tar.gz>

status: normal maintenance
release date: 2017-12-25

Ruby 2.4
........

<https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz>

status: normal maintenance
release date: 2016-12-25

Ruby 2.3
........

<https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.7.tar.gz>

status: security maintenance
release date: 2015-12-25
EOL date: scheduled for 2019-03-31

Ruby 2.2
........

status: eol
release date: 2014-12-25
EOL date: 2018-03-31


File: Ruby2_5.info,  Node: Issue Tracking,  Prev: Branches Page,  Up: Building From Source

2.1.4.3 Ruby Issue Tracking System
..................................

Bugs (https://bugs.ruby-lang.org)

How to report a bug
...................

How To Report
(https://bugs.ruby-lang.org/projects/ruby/wiki/HowToReport)

Ruby Trunk
..........

Ruby Trunk (https://bugs.ruby-lang.org/projects/ruby-trunk)

   All Issues
(https://bugs.ruby-lang.org/projects/ruby-trunk/issues?set_filter=1)


File: Ruby2_5.info,  Node: Developing Ruby,  Next: Getting Started,  Prev: Installing Ruby,  Up: Documentation

2.2 Developing Ruby
===================

Ruby Core (https://www.ruby-lang.org/en/community/ruby-core/)

   Now is a fantastic time to follow Ruby’s development.  With the
increased attention Ruby has received in the past few years, there’s a
growing need for good talent to help enhance Ruby and document its
parts.  So, where do you start?

Ruby Core
---------

The topics related to Ruby development covered here are:

   * *note Using Subversion to Track Ruby Development: subversion.
   * *note How to Use Git With the Main Ruby Repository: MainRubyRepo.
   * *note Improving Ruby: PatchByPatch.
   * Rules for Core Developers

Using Subversion to Track Ruby Development
..........................................

Getting the latest Ruby source code is a matter of an anonymous
checkout from the Subversion (http://subversion.apache.org/)
repository.  From your command line:

     $ svn co https://svn.ruby-lang.org/repos/ruby/trunk ruby

   The 'ruby' directory will now contain the latest source code for
the development version of Ruby ('ruby-trunk').  Currently patches
applied to the trunk are backported to the stable 2.5, 2.4, and 2.3
branches (see below).

   If you’d like to follow patching of Ruby 2.5, you should use the
ruby_2_5 branch when checking out:

     $ svn co https://svn.ruby-lang.org/repos/ruby/branches/ruby_2_5

   This will check out the respective development tree into a
'ruby_2_5' directory.  Developers working on the maintenance branches
are expected to migrate their changes to Ruby’s trunk, so often the
branches are very similar, with the exception of improvements made by
Matz and Nobu to the language itself.

   If you prefer, you may browse Ruby’s Subversion repository via the
web (https://svn.ruby-lang.org/cgi-bin/viewvc.cgi/).

How to Use Git With the Main Ruby Repository
............................................

Those who prefer to use Git over Subversion can find instructions with
the mirror on GitHub (https://github.com/ruby/ruby), both for those
with commit access and everybody else
(https://github.com/shyouhei/ruby/wiki/noncommitterhowto).

Improving Ruby, Patch by Patch
..............................

The core team maintains an issue tracker (https://bugs.ruby-lang.org/)
for submitting patches and bug reports to Matz and the gang.  These
reports also get submitted to the Ruby-Core mailing list
(https://www.ruby-lang.org/en/community/mailing-lists/) for
discussion, so you can be sure your request won’t go unnoticed.  You
can also send your patches straight to the mailing list.  Either way,
you are encouraged to take part in the discussion that ensues.

   Please look over the Patch Writer’s Guide
(https://www.ruby-lang.org/en/community/ruby-core/writing-patches/)
for some tips, straight from Matz, on how to get your patches
considered.

   Steps for Building a Patch
(https://www.ruby-lang.org/en/community/ruby-core/)


File: Ruby2_5.info,  Node: Getting Started,  Next: Manuals,  Prev: Developing Ruby,  Up: Documentation

2.3 Getting Started
===================

* Menu:

* Try Ruby!::
* Official FAQ::
* Ruby Koans::
* Why’s (Poignant) Guide to Ruby::
* Ruby in Twenty Minutes::
* Ruby from Other Languages::
* Important Language Features::
* Learning Ruby::
* Ruby Essentials::
* Learn to Program::


File: Ruby2_5.info,  Node: Try Ruby!,  Next: Official FAQ,  Up: Getting Started

2.3.1 Try Ruby!
---------------

Try Ruby!  (https://ruby.github.io/TryRuby/)

   An interactive tutorial that lets you try out Ruby right in your
browser.  This 15-minute tutorial is aimed at beginners who want to
get a feeling of the language.


File: Ruby2_5.info,  Node: Official FAQ,  Next: Ruby Koans,  Prev: Try Ruby!,  Up: Getting Started

2.3.2 Official FAQ
------------------

The official frequently asked questions.

   FAQ (https://www.ruby-lang.org/en/documentation/faq/)

   This document contains Frequently Asked Questions about Ruby with
answers.

   This FAQ is based on The Ruby Language FAQ
(http://ruby-doc.org/docs/ruby-doc-bundle/FAQ/FAQ.html) originally
compiled by Shugo Maeda and translated into English by Kentaro Goto.
Thanks to Zachary Scott and Marcus Stollsteimer for incorporating the
FAQ into the site and for a major overhaul of the content.

   * General questions
   * How does Ruby stack up against…?
   * Installing Ruby
   * Variables, constants, and arguments
   * *note FAQ Iterators::
   * *note FAQ Syntax::
   * Methods
   * Classes and modules
   * Built-in libraries
   * Extension library
   * Other features

* Menu:

* FAQ Iterators::
* FAQ Syntax::
* FAQ Methods::
* FAQ Classes and Modules::
* FAQ Built-In Libraries::
* FAQ Extension Library::
* FAQ Other Features::


File: Ruby2_5.info,  Node: FAQ Iterators,  Next: FAQ Syntax,  Up: Official FAQ

2.3.2.1 FAQ Iterators
.....................

What is an iterator?
--------------------

An iterator is a method which accepts a block or a 'Proc' object.  In
the source file, the block is placed immediately after the invocation
of the method.  Iterators are used to produce user-defined control
structures -- especially loops.

   Let’s look at an example to see how this works.  Iterators are
often used to repeat the same action on each element of a collection,
like this:

     data = [1, 2, 3]
     data.each do |i|
       puts i
     end

   The 'each' method of the array 'data' is passed the 'do ... end'
block, and executes it repeatedly.  On each call, the block is passed
successive elements of the array.

   You can define blocks with '{ ... }' in place of 'do ... end'.

     data = [1, 2, 3]
     data.each { |i|
       puts i
     }

   This code has the same meaning as the last example.  However, in
some cases, precedence issues cause 'do ... end' and '{ ... }' to act
differently.

     foobar a, b do ... end	# foobar is the iterator.
     foobar a, b { ... }	# b is the iterator.

   This is because '{ ... }' binds more tightly to the preceding
expression than does a 'do ... end' block.  The first example is
equivalent to 'foobar(a, b) do ... end', while the second is
'foobar(a, b { ... })'.

How can I pass a block to an iterator?
--------------------------------------

You simply place the block after the iterator call.  You can also pass
a 'Proc' object by prepending '&' to the variable or constant name
that refers to the 'Proc'.

How is a block used in an iterator?
-----------------------------------

_This section or parts of it might be out-dated or in need of
confirmation._

   There are three ways to execute a block from an iterator method:

  1. the 'yield' control structure;

     The 'yield' statement calls the block, optionally passing it one
     or more arguments.

          def my_iterator
            yield 1, 2
          end

          my_iterator {|a, b| puts a, b }

  2. calling a 'Proc' argument (made from a block) with 'call';

     If a method definition has a block argument (the last formal
     parameter has an ampersand ('&') prepended), it will receive the
     attached block, converted to a 'Proc' object.  This may be called
     using 'prc.call(args)'.

          def my_iterator(&b)
            b.call(1, 2)
          end

          my_iterator {|a, b| puts a, b }

     and

  3. using 'Proc.new' followed by a 'call'.

     'Proc.new' (or the equivalent 'proc' or 'lambda' calls), when
     used in an iterator definition, takes the block which is given to
     the method as its argument and generates a procedure object from
     it.  ('proc' and 'lambda' are effectively synonyms.)

     _[Update needed: 'lambda' behaves in a slightly different way and
     produces a warning 'tried to create Proc object without a
     block'.]_

          def my_iterator
            Proc.new.call(3, 4)
            proc.call(5, 6)
            lambda.call(7, 8)
          end

          my_iterator {|a, b| puts a, b }

     Perhaps surprisingly, 'Proc.new' and friends do not in any sense
     consume the block attached to the method -- each call to
     'Proc.new' generates a new procedure object out of the same
     block.

     You can tell if there is a block associated with a method by
     calling 'block_given?'.

What does Proc.new without a block do?
--------------------------------------

'Proc.new' without a block cannot generate a procedure object and an
error occurs.  In a method definition, however, 'Proc.new' without a
block implies the existence of a block at the time the method is
called, and so no error will occur.

How can I run iterators in parallel?
------------------------------------

See <http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/5252>


File: Ruby2_5.info,  Node: FAQ Syntax,  Next: FAQ Methods,  Prev: FAQ Iterators,  Up: Official FAQ

2.3.2.2 FAQ Syntax
..................

List of FAQ items:

   *note What is the difference between an immediate value and a
reference?: immediate value.

   *note What is the difference between 'nil' and 'false'?: nil vs
false.

   *note The Empty String: empty string.

   *note A Symbol Object: symbol object.

   *note How can I access the value of a symbol?: value of symbol.

   *note Is 'loop' a control structure?: loop.

   *note Ruby doesn't have a post-test loop: post-test loop.

   *note Why can’t I pass a hash literal to a method 'p {}'?: hash
literal.

   *note I can’t get 'def pos=(val)' to work!: pos val.

   *note What is the difference between '\1' and '\\1'?: \1 and \\1.

   *note What is the difference between '..' and '...'?: 2 dots vs 3
dots.

   *note What is the difference between or and ||?: or and.

   *note Does Ruby have function pointers?: function pointers.

   *note What is the difference between load and require?: load vs
require.

   *note Does Ruby have exception handling?: exception handling.

What is the difference between an immediate value and a reference?
------------------------------------------------------------------

'Fixnum', 'true', 'nil', and 'false' are implemented as "immediate
values".  With immediate values, variables hold the objects
themselves, rather than references to them.

   Singleton methods cannot be defined for such objects.  Two
'Fixnums' of the same value always represent the same object instance,
so (for example) instance variables for the 'Fixnum' with the value 1
are shared between all the 1's in the system.  This makes it
impossible to define a singleton method for just one of these.

What is the difference between 'nil' and 'false'?
-------------------------------------------------

First the similarity: 'nil' and 'false' are the only two objects that
evaluate to 'false' in a boolean context.  (In other words: they are
the only "falsy" values; all other objects are "truthy".)

   However, 'nil' and 'false' are instances of different classes
('NilClass' and 'FalseClass'), and have different behavior elsewhere.

   We recommend that "predicate methods" (those whose name ends with a
question mark) return 'true' or 'false'.  Other methods that need to
indicate failure should return 'nil'.

The Empty String
----------------

An empty string ('""') returns 'true' in a conditional expression!  In
Perl, it’s 'false'.  It’s very simple: in Ruby, only 'nil' and 'false'
are 'false' in conditional contexts.

   You can use 'empty?', compare the string to '""', or compare the
string’s size or length to 0 to find out if a string is empty.

A Symbol Object
---------------

What does ':name' mean?

   A colon followed by a name generates a "Symbol object" which
corresponds one-to-one with the identifier.  During the duration of a
program's execution the same Symbol object will be created for a given
name or string.  Symbols can also be created with '"name".intern' or
'"name".to_sym'.

   Symbol objects can represent identifiers for methods, variables,
and so on.  Some methods, like 'define_method', 'method_missing', or
'trace_var', require a symbol.  Other methods, e.g.  'attr_accessor',
'send', or 'autoload', also accept a string.

   Due to the fact that they are created only once, Symbols are often
used as hash keys.  String hash keys would create a new object for
every single use, thereby causing some memory overhead.  There is even
a special syntax for symbol hash keys:

     person_1 = { :name => "John", :age => 42 }
     person_2 = { name: "Jane", age: 24 }        # alternate syntax

   Symbols can also be used as enumeration values or to assign unique
values to constants:

     status = :open  # :closed, ...

     NORTH = :NORTH
     SOUTH = :SOUTH

How can I access the value of a symbol?
---------------------------------------

To get the value of the variable corresponding to a symbol, you can
use 'symbol.to_s' or '"#{symbol}"' to get the name of the variable,
and then 'eval' that in the scope of the symbol to get the variable’s
contents:

     a = "This is the content of `a'"
     b = eval("#{:a}")
     a.object_id == b.object_id  # => true

   You can also use:

     b = binding.local_variable_get(:a)

   If your symbol corresponds to the name of a method, you can use
'send':

     class Demo
       def hello
         "Hello, world"
       end
     end

     demo = Demo.new
     demo.send(:hello)

   Or you can use 'Object#method' to return a corresponding 'Method'
object, which you may then call:

     m = demo.method(:hello)  # => #<Method: Demo#hello>
     m.call                   # => "Hello, world"

Is 'loop' a control structure?
------------------------------

Although 'loop' looks like a control structure, it is actually a
method defined in 'Kernel'.  The block which follows introduces a new
scope for local variables.

Ruby doesn’t have a post-test loop
----------------------------------

Ruby does not have a 'do { ... } while' construct, so how can I
implement loops that test the condition at the end?

   Clemens Hintze says: "You can use a combination of Ruby’s 'begin
... end' and the 'while' or 'until' statement modifiers to achieve the
same effect:

     i = 0
     begin
       puts "i = #{i}"
       i += 1
     end until i > 4

Why can’t I pass a hash literal to a method: 'p {}'?
----------------------------------------------------

The '{}' is parsed as a block, not a 'Hash' constructor.  You can
force the '{}' to be treated as an expression by making the fact that
it's a parameter explicit: 'p({})'.

I can’t get 'def pos=(val)' to work!
------------------------------------

I have the following code, but I cannot use the method 'pos = 1'.

     def pos=(val)
       @pos = val
       puts @pos
     end

   Methods with '=' appended must be called with an explicit receiver
(without the receiver, you are just assigning to a local variable).
Invoke it as 'self.pos = 1'.

What is the difference between '\1' and '\\1'?
----------------------------------------------

They have the same meaning.  In a single quoted string, only '\'' and
'\\' are transformed and other combinations remain unchanged.

   However, in a double quoted string, '"\1"' is the byte '\001' (an
octal bit pattern), while '"\\1"' is the two character string
containing a backslash and the character '"1"'.

What is the difference between '..' and '...'?
----------------------------------------------

'..' includes the right hand side in the range, while '...' does not:

     (5..8).to_a   # => [5, 6, 7, 8]
     (5...8).to_a  # => [5, 6, 7]

What is the difference between 'or' and '||'?
---------------------------------------------

'p(nil || "Hello")' prints '"Hello"', while 'p(nil or "Hello")' gives
a parse error.  Why?

   'or' has a very low precedence; 'p( (nil or "Hello") )' will work.

   The precedence of 'or' is for instance also lower than that of '=',
whereas ' || ' has a higher precedence:

     foo = nil || "Hello"  # parsed as: foo = (nil || "Hello")
     foo  # => "Hello"

     # but perhaps surprisingly:

     foo = nil or "Hello"  # parsed as: (foo = nil) or "Hello"
     foo  # => nil

   'or' (and similarly 'and') is best used, not for combining boolean
expressions, but for control flow, like in:

     do_something  or raise "some error!"

   where 'do_something' returns 'false' or 'nil' when an error occurs.

Does Ruby have function pointers?
---------------------------------

A 'Proc' object generated by 'Proc.new', 'proc', or 'lambda' can be
referenced from a variable, so that variable could be said to be a
function pointer.  You can also get references to methods within a
particular object instance using 'object.method'.

What is the difference between load and require?
------------------------------------------------

'load' will load and execute a Ruby program ('*.rb').

   'require' loads Ruby programs as well, but will also load "binary
Ruby extension modules" (shared libraries or DLLs).  In addition,
'require' ensures that a feature is never loaded more than once.

Does Ruby have exception handling?
----------------------------------

Ruby supports a flexible exception handling scheme:

     begin
       statements which may raise exceptions
     rescue [exception class names]
       statements when an exception occurred
     rescue [exception class names]
       statements when an exception occurred
     ensure
       statements that will always run
     end

   If an exception occurs in the 'begin' clause, the 'rescue' clause
with the matching exception name is executed.  The 'ensure' clause is
executed whether an exception occurred or not.  'rescue' and 'ensure'
clauses may be omitted.

   If no exception class is designated for a 'rescue' clause,
'StandardError' exception is implied, and exceptions which are in a
'is_a?' relation to 'StandardError' are captured.

   This expression returns the value of the 'begin' clause.

   The latest exception is accessed by the global variable '$!' (and
so its type can be determined using '$!.type').


File: Ruby2_5.info,  Node: FAQ Methods,  Next: FAQ Classes and Modules,  Prev: FAQ Syntax,  Up: Official FAQ

2.3.2.3 FAQ Methods
...................

How does Ruby choose which method to invoke?
--------------------------------------------

Are '+, -, *, ...' operators?
-----------------------------

Where are '++' and '--' ?
-------------------------

What is a singleton method?
---------------------------

All these objects are fine, but does Ruby have any simple functions?
--------------------------------------------------------------------

So where do all these function-like methods come from?
------------------------------------------------------

Can I access an object’s instance variables?
--------------------------------------------

What’s the difference between 'private' and 'protected'?
--------------------------------------------------------

How can I change the visibility of a method?
--------------------------------------------

Can an identifier beginning with a capital letter be a method name?
-------------------------------------------------------------------

Calling 'super' gives an 'ArgumentError'.
-----------------------------------------

How can I call the method of the same name two levels up?
---------------------------------------------------------

How can I invoke an original built-in method after redefining it?
-----------------------------------------------------------------

What is a destructive method?
-----------------------------

Why can destructive methods be dangerous?
-----------------------------------------

Can I return multiple values from a method?
-------------------------------------------


File: Ruby2_5.info,  Node: FAQ Classes and Modules,  Next: FAQ Built-In Libraries,  Prev: FAQ Methods,  Up: Official FAQ

2.3.2.4 FAQ Classes and Modules
...............................

Can a class definition be repeated?
-----------------------------------

Are there class variables?
--------------------------

What is a class instance variable?
----------------------------------

What is the difference between class variables and class instance variables?
----------------------------------------------------------------------------

Does Ruby have class methods?
-----------------------------

What is a singleton class?
--------------------------

What is a module function?
--------------------------

What is the difference between a class and a module?
----------------------------------------------------

Can you subclass modules?
-------------------------

Give me an example of a mixin
-----------------------------

Why are there two ways of defining class methods?
-------------------------------------------------

What is the difference between include and extend?
--------------------------------------------------

What does 'self' mean?
----------------------


File: Ruby2_5.info,  Node: FAQ Built-In Libraries,  Next: FAQ Extension Library,  Prev: FAQ Classes and Modules,  Up: Official FAQ

2.3.2.5 FAQ Built-In Libraries
..............................

What does 'instance_methods(false)' return?
-------------------------------------------

How do random number seeds work?
--------------------------------

I read a file and changed it, but the file on disk has not changed.
-------------------------------------------------------------------

How can I process a file and update its contents?
-------------------------------------------------

I wrote a file, copied it, but the end of the copy seems to be lost.
--------------------------------------------------------------------

How can I get the line number in the current input file?
--------------------------------------------------------

How can I use 'less' to display my program’s output?
----------------------------------------------------

What happens to a 'File' object which is no longer referenced?
--------------------------------------------------------------

I feel uneasy if I don’t close a file.
--------------------------------------

How can I sort files by their modification time?
------------------------------------------------

How can I count the frequency of words in a file?
-------------------------------------------------

How can I sort strings in alphabetical order?
---------------------------------------------

How can I expand tabs to spaces?
--------------------------------

How can I escape a backslash in a regular expression?
-----------------------------------------------------

What is the difference between 'sub' and 'sub!'?
------------------------------------------------

Where does '\Z' match?
----------------------

What is the difference between 'thread' and 'fork'?
---------------------------------------------------

How can I use 'Marshal'?
------------------------

How can I use 'trap'?
---------------------


File: Ruby2_5.info,  Node: FAQ Extension Library,  Next: FAQ Other Features,  Prev: FAQ Built-In Libraries,  Up: Official FAQ

2.3.2.6 FAQ Extension Library
.............................

How can I use Ruby interactively?
---------------------------------

Is there a debugger for Ruby?
-----------------------------

How can I use a library written in C from Ruby?
-----------------------------------------------

Can I use 'Tcl/Tk' in Ruby?
---------------------------

'Tk' won't work. Why?
---------------------

Can I use 'gtk+' or 'xforms' interfaces in Ruby?
------------------------------------------------

How can I do date arithmetic?
-----------------------------


File: Ruby2_5.info,  Node: FAQ Other Features,  Prev: FAQ Extension Library,  Up: Official FAQ

2.3.2.7 FAQ Other Features
..........................

What does a ? b : c mean?
-------------------------

How can I count the number of lines in a file?
----------------------------------------------

What do 'MatchData#begin' and 'MatchData#end' return?
-----------------------------------------------------

How can I sum the elements in an array?
---------------------------------------

How can I use continuations?
----------------------------


File: Ruby2_5.info,  Node: Ruby Koans,  Next: Why’s (Poignant) Guide to Ruby,  Prev: Official FAQ,  Up: Getting Started

2.3.3 Ruby Koans
----------------

Ruby Koans (http://rubykoans.com/)

   The Koans walk you along the path to enlightenment in order to
learn Ruby.  The goal is to learn the Ruby language, syntax,
structure, and some common functions and libraries.  We also teach you
culture.


File: Ruby2_5.info,  Node: Why’s (Poignant) Guide to Ruby,  Next: Ruby in Twenty Minutes,  Prev: Ruby Koans,  Up: Getting Started

2.3.4 Why’s (Poignant) Guide to Ruby
------------------------------------

Why's Guide to Ruby (http://mislav.uniqpath.com/poignant-guide/)

   An unconventional but interesting book that will teach you Ruby
through stories, wit, and comics.  Originally created by 'why the
lucky stiff', this guide remains a classic for Ruby learners.


File: Ruby2_5.info,  Node: Ruby in Twenty Minutes,  Next: Ruby from Other Languages,  Prev: Why’s (Poignant) Guide to Ruby,  Up: Getting Started

2.3.5 Ruby in Twenty Minutes
----------------------------

Ruby in Twenty Minutes
(https://www.ruby-lang.org/en/documentation/quickstart/)

   A nice tutorial covering the basics of Ruby.  From start to finish
it shouldn’t take you more than twenty minutes.  It makes the
assumption that you already have Ruby installed.  (If you do not have
Ruby on your computer install it before you get started.)

* Menu:

* Interactive Ruby::
* Defining Methods::
* Altering Classes::
* Large Class Definition::
* Run MegaGreeter::


File: Ruby2_5.info,  Node: Interactive Ruby,  Next: Defining Methods,  Up: Ruby in Twenty Minutes

2.3.5.1 Interactive Ruby
........................

Ruby comes with a program that will show the results of any Ruby
statements you feed it.  Playing with Ruby code in interactive
sessions like this is a terrific way to learn the language.

   Open up 'IRB' (which stands for Interactive Ruby).

     ? irb
     -| irb(main):001:0>

     irb(main):001:0> "Hello World"
     => "Hello World"
     -| irb(main):002:0>

   The second line is just IRB’s way of telling us the result of the
last expression it evaluated.  To print:

     irb(main):002:0> puts "Hello World"
     -| Hello World
     => nil
     -| irb(main):003:0>

   'puts' is the basic command to print something out in Ruby.  But
then what’s the '=> nil' bit?  That’s the result of the expression.
'puts' always returns 'nil', which is Ruby’s
absolutely-positively-nothing value.


File: Ruby2_5.info,  Node: Defining Methods,  Next: Altering Classes,  Prev: Interactive Ruby,  Up: Ruby in Twenty Minutes

2.3.5.2 Defining Methods
........................

Define a method:

     irb(main):010:0> def hi
     irb(main):011:1> puts "Hello World!"
     irb(main):012:1> end
     => :hi

   The code 'def hi' starts the definition of the method.  The next
line is the body of the method.  Finally, the last line end tells Ruby
we’re done defining the method.  Ruby’s response -| '=> :hi' tells us
that it knows we're done defining the method.

   Try running that method a few times:

     irb(main):013:0> hi
     Hello World!
     => nil
     irb(main):014:0> hi()
     Hello World!
     => nil

   If the method doesn't take parameters that's all you need.  You can
add empty parentheses if you’d like, but they’re not needed.

Define Method with a Parameter
..............................

What if we want to say hello to one person, and not the whole world?
Just redefine 'hi' to take a name as a parameter.

     irb(main):015:0> def hi(name)
     irb(main):016:1> puts "Hello #{name}!"
     irb(main):017:1> end
     => :hi
     irb(main):018:0> hi("Matz")
     Hello Matz!
     => nil

   What's the '#{name}' bit?  That's Ruby's way of inserting something
into a string.  The bit between the braces is turned into a string (if
it isn’t one already) and then substituted into the outer string at
that point.  You can also use this to make sure that someone's name is
properly capitalized:

     irb(main):019:0> def hi(name = "World")
     irb(main):020:1> puts "Hello #{name.capitalize}!"
     irb(main):021:1> end
     => :hi
     irb(main):022:0> hi "chris"
     Hello Chris!
     => nil
     irb(main):023:0> hi
     Hello World!
     => nil

   A couple of other tricks to spot here.  One is that we're calling
the method without parentheses again.  If it's obvious what you’re
doing, the parentheses are optional.  The other trick is the default
parameter World.  What this is saying is "If the name isn't supplied,
use the default name of "World"".

Create a Class
--------------

What if we want a real greeter around, one that remembers your name
and welcomes you and treats you always with respect.  You might want
to use an object for that.  Let’s create a “Greeter” class.

     irb(main):024:0> class Greeter
     irb(main):025:1>   def initialize(name = "World")
     irb(main):026:2>     @name = name
     irb(main):027:2>   end
     irb(main):028:1>   def say_hi
     irb(main):029:2>     puts "Hi #{@name}!"
     irb(main):030:2>   end
     irb(main):031:1>   def say_bye
     irb(main):032:2>     puts "Bye #{@name}, come back soon."
     irb(main):033:2>   end
     irb(main):034:1> end
     => :say_bye

   The new keyword here is 'class'.  This defines a new class called
'Greeter' and a bunch of methods for that class.  Also notice '@name'.
This is an instance variable, and is available to all the methods of
the class.  As you can see it’s used by 'say_hi' and 'say_bye'.

Create an Object
----------------

Now let’s create a greeter object and use it:

     irb(main):035:0> greeter = Greeter.new("Pat")
     => #<Greeter:0x16cac @name="Pat">
     irb(main):036:0> greeter.say_hi
     Hi Pat!
     => nil
     irb(main):037:0> greeter.say_bye
     Bye Pat, come back soon.
     => nil

Instance Variables
------------------

Instance variables are hidden away inside the object.  They’re not
terribly hidden, you see them whenever you inspect the object, and
there are other ways of accessing them, but Ruby uses the good
object-oriented approach of keeping data sort-of hidden away.

   So what methods do exist for Greeter objects?

   'Object#instance_methods'

     irb(main):039:0> Greeter.instance_methods
     => [:say_hi, :say_bye, :instance_of?, :public_send,
         :instance_variable_get, :instance_variable_set,
         :instance_variable_defined?, :remove_instance_variable,
         :private_methods, :kind_of?, :instance_variables, :tap,
         :is_a?, :extend, :define_singleton_method, :to_enum,
         :enum_for, :<=>, :===, :=~, :!~, :eql?, :respond_to?,
         :freeze, :inspect, :display, :send, :object_id, :to_s,
         :method, :public_method, :singleton_method, :nil?, :hash,
         :class, :singleton_class, :clone, :dup, :itself, :taint,
         :tainted?, :untaint, :untrust, :trust, :untrusted?, :methods,
         :protected_methods, :frozen?, :public_methods, :singleton_methods,
         :!, :==, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]

   We only defined two methods.  What’s going on here?  Well this is
all of the methods for Greeter objects, a complete list, including
ones defined by ancestor classes.  If we want to just list methods
defined for Greeter we can tell it to not include ancestors by passing
it the parameter false, meaning we don’t want methods defined by
ancestors.

   'Object#instance_methods(false)'

     irb(main):040:0> Greeter.instance_methods(false)
     => [:say_hi, :say_bye]

   So let’s see which methods our greeter object responds to:

   'Object#respond_to?'

     irb(main):041:0> greeter.respond_to?("name")
     => false
     irb(main):042:0> greeter.respond_to?("say_hi")
     => true
     irb(main):043:0> greeter.respond_to?("to_s")
     => true

   So, it knows 'say_hi', and 'to_s' (meaning convert something to a
string, a method that's defined by default for every object), but it
doesn't know 'name'.


File: Ruby2_5.info,  Node: Altering Classes,  Next: Large Class Definition,  Prev: Defining Methods,  Up: Ruby in Twenty Minutes

2.3.5.3 Altering Classes
........................

But what if you want to be able to view or change the name?  Ruby
provides an easy way of providing access to an object's variables.

   'attr_accessor :name'

     irb(main):044:0> class Greeter
     irb(main):045:1>   attr_accessor :name
     irb(main):046:1> end
     => nil

   In Ruby, you can open a class up again and modify it.  The changes
will be present in any new objects you create and even available in
existing objects of that class.  So, let’s create a new object and
play with its '@name' property.

     irb(main):047:0> greeter = Greeter.new("Andy")
     => #<Greeter:0x3c9b0 @name="Andy">
     irb(main):048:0> greeter.respond_to?("name")
     => true
     irb(main):049:0> greeter.respond_to?("name=")
     => true
     irb(main):050:0> greeter.say_hi
     Hi Andy!
     => nil
     irb(main):051:0> greeter.name="Betty"
     => "Betty"
     irb(main):052:0> greeter
     => #<Greeter:0x3c9b0 @name="Betty">
     irb(main):053:0> greeter.name
     => "Betty"
     irb(main):054:0> greeter.say_hi
     Hi Betty!
     => nil

   Using 'attr_accessor' defined two new methods for us, 'name' to get
the value, and 'name=' to set it.


File: Ruby2_5.info,  Node: Large Class Definition,  Next: Run MegaGreeter,  Prev: Altering Classes,  Up: Ruby in Twenty Minutes

2.3.5.4 Large Class Definition
..............................

What if we had some kind of MegaGreeter that could either greet the
world, one person, or a whole list of people?  Let’s write this one in
a file instead of directly in the interactive Ruby interpreter IRB.

{'ri20min.rb'} ==
     #!/usr/bin/env ruby

     class MegaGreeter
       attr_accessor :names

       <MegaGreeter--Initialize Method>
       <MegaGreeter--say_hi Method>
       <MegaGreeter--say_bye Method>
     end

     if __FILE__ == $0
       <MegaGreeter--Main Script>
     end


The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<MegaGreeter--Initialize  See *note MegaGreeter---Initialize-Method::.
Method>
<MegaGreeter--Main        See *note MegaGreeter---Main-Script::.
Script>
<MegaGreeter--say_bye     See *note MegaGreeter---say-bye-Method::.
Method>
<MegaGreeter--say_hi      See *note MegaGreeter---say-hi-Method::.
Method>

Initialize Method
.................

<MegaGreeter--Initialize Method> ==
       # Create the object
       def initialize(names = "World")
         @names = names
       end


This chunk is called by {'ri20min.rb'}; see its first definition at
*note ri20min-rb::.

'say_hi' Method
---------------

The 'say_hi' method has become a bit more complicated.  It now looks
at the '@names' instance variable to make decisions.  If it's 'nil',
it just prints out three dots.  No point greeting nobody, right?

   If the '@names' object responds to each, it is something that you
can iterate over, so iterate over it and greet each person in turn.
Finally, if '@names' is anything else, just let it get turned into a
string automatically and do the default greeting.

<MegaGreeter--say_hi Method> ==
       # Say hi to everybody
       def say_hi
         if @names.nil?
           puts "..."
         elsif @names.respond_to?("each")
           # @names is a list of some kind, iterate!
           @names.each do |name|
             puts "Hello #{name}!"
           end
         else
           puts "Hello #{@names}!"
         end
       end


This chunk is called by {'ri20min.rb'}; see its first definition at
*note ri20min-rb::.

The Iterator
............

Let’s look at that iterator in more depth:

     @names.each do |name|
       puts "Hello #{name}!"
     end

   'each' is a method that accepts a block of code then runs that
block of code for every element in a list, and the bit between 'do'
and 'end' is just such a block.  A "block" is like an anonymous
function or lambda.  The variable between pipe characters is the
parameter for this block.

   What happens here is that for every entry in a list, 'name' is
bound to that list element, and then the expression puts '"Hello
#{name}!"' is run with that name.

   Internally, the 'each' method will essentially call 'yield'
'"Albert"', then 'yield' '"Brenda"' and then 'yield' '"Charles"', and
so on.

The Real Power of Blocks
........................

The real power of blocks is when dealing with things that are more
complicated than lists.  Beyond handling simple housekeeping details
within the method, you can also handle setup, teardown, and errors—all
hidden away from the cares of the user.

'say_bye' Method
----------------

The 'say_bye' method doesn't use 'each'; instead it checks to see if
'@names' "responds" to the 'join' method, and if so, uses it.
Otherwise, it just prints out the variable as a string.

Duck Typing
...........

This method of not caring about the actual type of a variable, just
relying on what methods it supports is known as "Duck Typing", as in
"if it walks like a duck and quacks like a duck...".  The benefit of
this is that it doesn't unnecessarily restrict the types of variables
that are supported.  If someone comes up with a new kind of list
class, as long as it implements the 'join' method with the same
semantics as other lists, everything will work as planned.

<MegaGreeter--say_bye Method> ==
       # Say bye to everybody
       def say_bye
         if @names.nil?
           puts "..."
         elsif @names.respond_to?("join")
           # Join the list elements with commas
           puts "Goodbye #{@names.join(", ")}.  Come back soon!"
         else
           puts "Goodbye #{@names}.  Come back soon!"
         end
       end


This chunk is called by {'ri20min.rb'}; see its first definition at
*note ri20min-rb::.

MegaGreeter Main Script
-----------------------

There’s one final trick to notice, and that’s the line:

     if __FILE__ == $0

   __FILE__ is the magic variable that contains the name of the
current file.  $0 is the name of the file used to start the program.
This check says "If this is the main file being used..." This allows a
file to be used as a library, and not to execute code in that context,
but if the file is being used as an executable, then execute that
code.

<MegaGreeter--Main Script> ==
       mg = MegaGreeter.new
       mg.say_hi
       mg.say_bye

       # Change name to be "Zeke"
       mg.names = "Zeke"
       mg.say_hi
       mg.say_bye

       # Change the name to an array of names
       mg.names = ["Albert", "Brenda", "Charles",
                   "Dave", "Engelbert"]
       mg.say_hi
       mg.say_bye

       # Change to nil
       mg.names = nil
       mg.say_hi
       mg.say_bye


This chunk is called by {'ri20min.rb'}; see its first definition at
*note ri20min-rb::.


File: Ruby2_5.info,  Node: Run MegaGreeter,  Prev: Large Class Definition,  Up: Ruby in Twenty Minutes

2.3.5.5 Run MegaGreeter
.......................

Run the program 'ri20min.rb' as 'ruby ri20min.rb'.  The output should
be:

     Hello World!
     Goodbye World.  Come back soon!
     Hello Zeke!
     Goodbye Zeke.  Come back soon!
     Hello Albert!
     Hello Brenda!
     Hello Charles!
     Hello Dave!
     Hello Engelbert!
     Goodbye Albert, Brenda, Charles, Dave, Engelbert.  Come back soon!
     ...
     ...


File: Ruby2_5.info,  Node: Ruby from Other Languages,  Next: Important Language Features,  Prev: Ruby in Twenty Minutes,  Up: Getting Started

2.3.6 Ruby from Other Languages
-------------------------------

Ruby from Other Languages
(https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/)

   This document contains two major sections.  The first attempts to
be a rapid-fire summary of what you can expect to see when going from
language X to Ruby.  The second section tackles the major language
features and how they might compare to what you’re already familiar
with.

* Menu:

* To Ruby From C and C++::
* To Ruby From Java::
* To Ruby From Perl::
* To Ruby From PHP::
* To Ruby From Python::


File: Ruby2_5.info,  Node: To Ruby From C and C++,  Next: To Ruby From Java,  Up: Ruby from Other Languages

2.3.6.1 To Ruby From C and C++
..............................

Everything Is Differerent
-------------------------

It's difficult to write a bulleted list describing how your code will
be different in Ruby from C or C++ because it's quite a large
difference.  One reason is that the Ruby runtime does so much for you.
Ruby seems about as far as you can get from C's "no hidden mechanism"
principle--the whole point of Ruby is to make the human's job easier
at the expense of making the runtime shoulder more of the work.

Ruby is Quicker to Code But Slower to Execute
.............................................

That said, for one thing, you can expect your Ruby code to execute
much more slowly than "equivalent" C or C++ code.  At the same time,
your head will spin at how rapidly you can get a Ruby program up and
running, as well as at how few lines of code it will take to write it.
Ruby is much much simpler than C++.

Dynamically Typed
-----------------

Ruby is dynamically typed, rather than statically typed--the runtime
does as much as possible at run-time.  For example, you don't need to
know what modules your Ruby program will "link to" (that is, load and
use) or what methods it will call ahead of time.

Extension Modules
-----------------

Happily, it turns out that Ruby and C have a healthy symbiotic
relationship.  Ruby supports so-called "extension modules".  These are
modules that you can use from your Ruby programs (and which, from the
outside, will look and act just like any other Ruby module), but which
are written in C. In this way, you can compartmentalize the
performance-critical parts of your Ruby software, and smelt those down
to pure C.

   And, of course, Ruby itself is written in C.

Similarities With C
-------------------

   * You may program procedurally if you like (but it will still be
     object-oriented behind the scenes).
   * Most of the operators are the same (including the compound
     assignment and also bitwise operators).  Though, Ruby doesn’t
     have '++' or '--'.
   * Ruby has __FILE__ and __LINE__.
   * You can also have constants, though there’s no special const
     keyword.  'Const'-ness is enforced by a naming convention instead
     -- names starting with a capital letter are for constants.
   * Strings go in double-quotes and are mutable
   * Just like man pages, you can read most docs in your terminal
     window -- though using the 'ri' command.
   * You’ve got the same sort of command-line debugger available.

Similarities with C++
---------------------

   * You’ve got mostly the same operators (even '::').  '<<' is often
     used for appending elements to a list.  One note though: with
     Ruby you never use '->' -- it's always just '.'.
   * 'public', 'private', and 'protected' do similar jobs.
   * Inheritance syntax is still only one character, but it's '<'
     instead of ':'.
   * You may put your code into "modules", similar to how 'namespace'
     in C++ is used.
   * Exceptions work in a similar manner, though the keyword names
     have been changed to protect the innocent.

Differences From C
------------------

   * You don’t need to compile your code.  You just run it directly.
   * Objects are strongly typed (and variable names themselves have no
     type at all).
   * There’s no macros or preprocessor; no casts; no pointers (nor
     pointer arithmetic); no typedefs, sizeof, or enums.
   * There are no header files.  You just define your functions
     (usually referred to as "methods") and classes in the main source
     code files.
   * There’s no '#define'.  Just use constants instead.
   * All variables live on the heap.  Further, you don’t need to free
     them yourself -- the garbage collector takes care of that.
   * Arguments to methods (i.e.  functions) are passed by value, where
     the values are always object references.
   * It's 'require 'foo'' instead of '#include <foo>' or '#include
     "foo"'.
   * You cannot drop down to assembly.
   * There’s no semicolons ending lines.
   * You go without parentheses for 'if' and 'while' condition
     expressions.
   * Parentheses for method (i.e.  function) calls are often optional.
   * You don’t usually use braces -- just end multi-line constructs
     (like 'while' loops) with an 'end' keyword.
   * The 'do' keyword is for so-called "blocks".  There’s no "do
     statement" like in C.
   * The term "block" means something different.  It's for a block of
     code that you associate with a method call so the method body can
     call out to the block while it executes.
   * There are no variable declarations.  You just assign to new names
     on-the-fly when you need them.
   * When tested for truth, only 'false' and 'nil' evaluate to a
     'false' value.  Everything else is true (including '0', '0.0',
     and '"0"').
   * There is no 'char' -- they are just 1-letter strings.
   * Strings don’t end with a null byte.
   * Array literals go in brackets instead of braces.
   * Arrays just automatically get bigger when you stuff more elements
     into them.
   * If you add two arrays, you get back a new and bigger array (of
     course, allocated on the heap) instead of doing pointer
     arithmetic.
   * More often than not, everything is an expression (that is, things
     like 'while' statements actually evaluate to an 'rvalue').

Differences from C++
--------------------

   * There’s no explicit references.  That is, in Ruby, every variable
     is just an automatically dereferenced name for some object.
   * Objects are strongly but _dynamically_ typed.  The runtime
     discovers _at runtime_ if that method call actually works.
   * The "constructor" is called 'initialize' instead of the class
     name.
   * All methods are always virtual.
   * "Class" ('static') variable names always begin with '@@' (as in
     '@@total_widgets').
   * You don’t directly access member variables -- all access to
     public member variables (known in Ruby as "attributes") is via
     methods.
   * It's 'self' instead of 'this'.
   * Some methods end in a '?' or a '!'.  It's actually part of the
     method name.
   * There's no multiple inheritance per se.  Though Ruby has "mixins"
     (i.e.  you can "inherit" all instance methods of a module).
   * There are some enforced case-conventions (ex.  class names start
     with a capital letter, variables start with a lowercase letter).
   * Parentheses for method calls are usually optional.
   * You can re-open a class anytime and add more methods.
   * There’s no need of C++ templates (since you can assign any kind
     of object to a given variable, and types get figured out at
     runtime anyway).  No casting either.
   * Iteration is done a bit differently.  In Ruby, you don't use a
     separate iterator object (like 'vector<T>::const_iterator iter').
     Instead you use an iterator method of the container object (like
     'each') that takes a block of code to which it passes successive
     elements.
   * There’s only two container types: 'Array' and 'Hash'.
   * There’s no type conversions.  With Ruby though, you’ll probably
     find that they aren’t necessary.
   * Multithreading is built-in, but as of Ruby 1.8 they are "green
     threads" (implemented only within the interpreter) as opposed to
     native threads.
   * A unit testing lib comes standard with Ruby.


File: Ruby2_5.info,  Node: To Ruby From Java,  Next: To Ruby From Perl,  Prev: To Ruby From C and C++,  Up: Ruby from Other Languages

2.3.6.2 To Ruby From Java
.........................

Ruby is Less Verbose
--------------------

Java is mature.  It's tested.  And it's fast (contrary to what the
anti-Java crowd may still claim).  It's also quite verbose.  Going
from Java to Ruby, expect your code size to shrink down considerably.
You can also expect it to take less time to knock together quick
prototypes.

Similarities with Java
----------------------

   * Memory is managed for you via a garbage collector.
   * Objects are strongly typed.
   * There are 'public', 'private', and 'protected' methods.
   * There are embedded doc tools (Ruby's is called 'RDoc').  The docs
     generated by 'rdoc' look very similar to those generated by
     'javadoc'.

Differences From Java
---------------------

   * You don’t need to compile your code.  You just run it directly.
   * There are several different popular third-party GUI toolkits.
     Ruby users can try 'WxRuby', 'FXRuby', 'Ruby-GNOME2', 'Qt', or
     the bundled-in 'Ruby Tk' for example.
   * You use the 'end' keyword after defining things like classes,
     instead of having to put braces around blocks of code.
   * You have 'require' instead of 'import'.
   * All member variables are private.  From the outside, you access
     everything via methods.
   * Parentheses in method calls are usually optional and often
     omitted.
   * Everything is an object, including numbers like '2' and
     '3.14159'.
   * There’s no static type checking.
   * Variable names are just labels.  They don’t have a type
     associated with them.
   * There are no type declarations.  You just assign to new variable
     names as-needed and they just "spring up" (i.e.  'a = [1,2,3]'
     rather than 'int[] a = {1,2,3};').
   * There’s no casting.  Just call the methods.  Your unit tests
     should tell you before you even run the code if you’re going to
     see an exception.
   * It's 'foo = Foo.new("hi")' instead of 'Foo foo = new Foo("hi")'.
   * The constructor is always named 'initialize' instead of the name
     of the class.
   * You have "mixins" instead of interfaces.
   * YAML tends to be favored over XML.
   * It's 'nil' instead of 'null'.
   * '==' and 'equals()' are handled differently in Ruby.  Use '=='
     when you want to test "equivalence" in Ruby ('equals()' in Java).
     Use 'equal?()' when you want to know if two objects are "the
     same" ('==' in Java).


File: Ruby2_5.info,  Node: To Ruby From Perl,  Next: To Ruby From PHP,  Prev: To Ruby From Java,  Up: Ruby from Other Languages

2.3.6.3 To Ruby From Perl
.........................

Perl is awesome.  Perl's docs are awesome.  The Perl community is --
awesome.  However, the language is fairly large and arguably complex.
For those Perlers who long for a simpler time, a more orthogonal
language, and elegant OO features built-in from the beginning, Ruby
may be for you.

Similarities with Perl
----------------------

   * You’ve got a package management system, somewhat like CPAN
     (though it’s called RubyGems (http://guides.rubygems.org/)).
   * Regexes are built right in.
   * There's a fairly large number of commonly-used built-ins.
   * Parentheses are often optional.
   * Strings work basically the same.
   * There’s a general delimited string and regex quoting syntax
     similar to Perl’s.  It looks like %q{this} (single-quoted), or
     %Q{this} (double-quoted), and %w{this for a single-quoted
     list of words}.  You %Q|can| %Q(use) %Q^other^ delimiters if you
     like.
   * You’ve got double-quotish variable interpolation, though it
     '"looks #{like} this"' (and you can put any Ruby code you like
     inside that '#{}').
   * Shell command expansion uses '`backticks`'.
   * You’ve got embedded doc tools (Ruby’s is called 'rdoc').

Differences From Perl
---------------------

   * You don’t have the context-dependent rules like with Perl.
   * A variable isn't the same as the object to which it refers.
     Instead, it's always just a reference to an object.
   * Although '$' and '@' are used as the first character in variable
     names sometimes, rather than indicating type, they indicate scope
     ('$' for globals, '@' for object instance, and '@@' for class
     attributes).
   * Array literals go in brackets instead of parentheses.
   * Composing lists of other lists does not flatten them into one big
     list.  Instead you get an array of arrays.
   * It's 'def' instead of 'sub'.
   * There's no semicolons needed at the end of each line.
     Incidentally, you end things like function definitions, class
     definitions, and case statements with the 'end' keyword.
   * Objects are strongly typed.  You’ll be manually calling
     'foo.to_i', 'foo.to_s', etc., if you need to convert between
     types.
   * There’s no 'eq', 'ne', 'lt', 'gt', 'ge', nor 'le'.
   * There’s no diamond operator ('<>').  You usually use
     'IO.some_method' instead.
   * The fat comma '=>' is only used for hash literals.
   * There’s no 'undef'.  In Ruby you have 'nil'.  'nil' is an object
     (like anything else in Ruby).  It's not the same as an undefined
     variable.  It evaluates to 'false' if you treat it like a
     boolean.
   * When tested for truth, only 'false' and 'nil' evaluate to a
     'false' value.  Everything else is 'true' (including '0', '0.0',
     and '"0"').


File: Ruby2_5.info,  Node: To Ruby From PHP,  Next: To Ruby From Python,  Prev: To Ruby From Perl,  Up: Ruby from Other Languages

2.3.6.4 To Ruby From PHP
........................

PHP is in widespread use for web applications, but if you want to use
Ruby on Rails or just want a language that’s more tailored for general
use, Ruby is worth a look.

Similarities with PHP
---------------------

   * Ruby is dynamically typed, like in PHP, so you don’t need to
     worry about having to declare variables.
   * There are classes, and you can control access to them like in PHP
     5 (public, protected and private).
   * Some variables start with '$', like in PHP (but not all).
   * There's 'eval', too.
   * You can use string interpolation.  Instead of doing '"$foo is a
     $bar"', you can do '"#{foo} is a #{bar}"' -- like in PHP, this
     doesn’t apply for single-quoted strings.
   * There’s heredocs.
   * Ruby has exceptions, like PHP 5.
   * There’s a fairly large standard library.
   * Arrays and hashes work like expected, if you exchange 'array()'
     for '{' and '}': 'array('a' => 'b')' becomes '{'a' => 'b'}'.
   * 'true' and 'false' behave like in PHP, but 'null' is called
     'nil'.

Differences From PHP
--------------------

   * There’s strong typing.  You’ll need to call 'to_s', 'to_i' etc.
     to convert between strings, integers and so on, instead of
     relying on the language to do it.
   * Strings, numbers, arrays, hashes, etc.  are objects.  Instead of
     calling 'abs(-1)' it’s '-1.abs'.
   * Parentheses are optional in method calls, except to clarify which
     parameters go to which method calls.
   * The standard library and extensions are organized in modules and
     classes.
   * Reflection is an inherent capability of objects; you don’t need
     to use 'Reflection' classes like in PHP 5.
   * Variables are references.
   * There’s no 'abstract' classes or 'interfaces'.
   * Hashes and arrays are not interchangeable.
   * Only 'false' and 'nil' are false: '0', 'array()' and '""' are all
     true in conditionals.
   * Almost everything is a method call, even 'raise' ('throw' in
     PHP).


File: Ruby2_5.info,  Node: To Ruby From Python,  Prev: To Ruby From PHP,  Up: Ruby from Other Languages

2.3.6.5 To Ruby From Python
...........................

Python is another very nice general purpose programming language.
Going from Python to Ruby, you'll find that there's a little bit more
syntax to learn than with Python.

Similarities With Python
------------------------

   * There’s an interactive prompt (called 'irb').
   * You can read docs on the command line (with the 'ri' command
     instead of 'pydoc').
   * There are no special line terminators (except the usual newline).
   * String literals can span multiple lines like Python's
     triple-quoted strings.
   * Brackets are for lists, and braces are for dicts (which, in Ruby,
     are called "hashes").
   * Arrays work the same (adding them makes one long array, but
     composing them like this 'a3 = [ a1, a2 ]' gives you an array of
     arrays).
   * Objects are strongly and dynamically typed.
   * Everything is an object, and variables are just references to
     objects.
   * Although the keywords are a bit different, exceptions work about
     the same.
   * You’ve got embedded doc tools (Ruby’s is called 'rdoc').
   * There is good support for functional programming with first-class
     functions, anonymous functions, and closures.

Differences From Python
-----------------------

   * Strings are mutable.
   * You can make constants (variables whose value you don’t intend to
     change).
   * There are some enforced case-conventions (ex.  class names start
     with a capital letter, variables start with a lowercase letter).
   * There's only one kind of list container (an 'Array'), and it's
     mutable.
   * Double-quoted strings allow escape sequences (like '\t') and a
     special "expression substitution" syntax (which allows you to
     insert the results of Ruby expressions directly into other
     strings without having to '"add " + "strings " + "together"').
     Single-quoted strings are like Python's 'r"raw strings"'.
   * There are no "new style" and "old style" classes.  Just one kind.
     (Python 3+ doesn’t have this issue, but it isn’t fully backward
     compatible with Python 2.)
   * You never directly access attributes.  With Ruby, it’s all method
     calls.
   * Parentheses for method calls are usually optional.
   * There's 'public', 'private', and 'protected' to enforce access,
     instead of Python's '_voluntary_' underscore '__convention__'.
   * "mixins" are used instead of multiple inheritance.
   * You can add or modify the methods of built-in classes.  Both
     languages let you open up and modify classes at any point, but
     Python prevents modification of built-ins -- Ruby does not.
   * You’ve got 'true' and 'false' instead of 'True' and 'False' (and
     'nil' instead of 'None').
   * When tested for truth, only 'false' and 'nil' evaluate to a
     'false' value.  Everything else is 'true' (including '0', '0.0',
     '""', and '[]').
   * It's 'elsif' instead of 'elif'.
   * It's 'require' instead of 'import'.  Otherwise though, usage is
     the same.
   * The usual-style comments on the line(s) above things (instead of
     docstrings below them) are used for generating docs.
   * There are a number of shortcuts that, although give you more to
     remember, you quickly learn.  They tend to make Ruby fun and very
     productive.
   * There’s no way to unset a variable once set (like Python's 'del'
     statement).  You can reset a variable to 'nil', allowing the old
     contents to be garbage collected, but the variable will remain in
     the symbol table as long as it is in scope.
   * The 'yield' keyword behaves differently.  In Python it will
     return execution to the scope outside the function's invocation.
     External code is responsible for resuming the function.  In Ruby
     'yield' will execute another function that has been passed as the
     final argument, then immediately resume.
   * Python supports just one kind of anonymous functions, lambdas,
     while Ruby contains blocks, Procs, and lambdas.


File: Ruby2_5.info,  Node: Important Language Features,  Next: Learning Ruby,  Prev: Ruby from Other Languages,  Up: Getting Started

2.3.7 Important Language Features
---------------------------------

Here are some pointers and hints on major Ruby features you'll see
while learning Ruby.

* Menu:

* Pointers on Iteration::
* Everything has a value::
* Symbols are not lightweight Strings::
* Everything is an Object::
* Variable Constants::
* Naming conventions::
* Keyword arguments::
* The universal truth::
* Access modifiers are Methods::
* Method access::
* Classes are open::
* Funny method names::
* Singleton methods::
* Missing methods::
* Message passing --- not function calls::
* Blocks are Objects::
* Operators are syntactic sugar::


File: Ruby2_5.info,  Node: Pointers on Iteration,  Next: Everything has a value,  Up: Important Language Features

2.3.7.1 Pointers on Iteration
.............................

Two Ruby features that are a bit unlike what you may have seen before,
and which take some getting used to, are "blocks" and iterators.
Instead of looping over an index (like with C, C++, or pre-1.5 Java),
or looping over a list (like Perl's 'for (@a) {...}', or Python's 'for
i in aList: ...'), with Ruby you'll very often instead see:

     some_list.each do |this_item|
       # We're inside the block.
       # deal with this_item.
     end

   For more info on 'each' and its friends

   * 'collect',
   * 'find',
   * 'inject',
   * 'sort',

   etc., see 'ri Enumerable' (and then 'ri Enumerable#some_method').


File: Ruby2_5.info,  Node: Everything has a value,  Next: Symbols are not lightweight Strings,  Prev: Pointers on Iteration,  Up: Important Language Features

2.3.7.2 Everything has a value
..............................

There’s no difference between an expression and a statement.
Everything has a value, even if that value is 'nil'.  This is
possible:

     x = 10
     y = 11
     z = if x < y
           true
         else
           false
         end
     z # => true


File: Ruby2_5.info,  Node: Symbols are not lightweight Strings,  Next: Everything is an Object,  Prev: Everything has a value,  Up: Important Language Features

2.3.7.3 Symbols are not lightweight Strings
...........................................

Many Ruby newbies struggle with understanding what Symbols are, and
what they can be used for.

   "Symbols" can best be described as identities.  A symbol is all
about who it is, not what it is.  Fire up 'irb' and see the
difference:

     irb(main):001:0> :george.object_id == :george.object_id
     => true
     irb(main):002:0> "george".object_id == "george".object_id
     => false
     irb(main):003:0>

   The 'object_id' methods returns the identity of an Object.  If two
objects have the same 'object_id', they are the same (point to the
same Object in memory).

   As you can see, once you have used a Symbol once, any Symbol with
the same characters references the same Object in memory.  For any
given two Symbols that represent the same characters, the 'object_id's
match.

   Now take a look at the String ('“george”').  The 'object_id's don't
match.  That means they're referencing two different objects in
memory.  Whenever you use a new String, Ruby allocates memory for it.

   If you're in doubt whether to use a Symbol or a String, consider
what’s more important: the identity of an object (i.e.  a Hash key),
or the contents (in the example above, '“george”').


File: Ruby2_5.info,  Node: Everything is an Object,  Next: Variable Constants,  Prev: Symbols are not lightweight Strings,  Up: Important Language Features

2.3.7.4 Everything is an Object
...............................

     ``Everything is an object'' isn't just hyperbole.  Even classes and integers are
     objects, and you can do the same things with them as with any other object:

     # This is the same as
     # class MyClass
     #   attr_accessor :instance_var
     # end
     MyClass = Class.new do
       attr_accessor :instance_var
     end


File: Ruby2_5.info,  Node: Variable Constants,  Next: Naming conventions,  Prev: Everything is an Object,  Up: Important Language Features

2.3.7.5 Variable Constants
..........................

Constants are not really constant.  If you modify an already
initialized constant, it will trigger a warning, but not halt your
program.  That isn't to say you should redefine constants, though.


File: Ruby2_5.info,  Node: Naming conventions,  Next: Keyword arguments,  Prev: Variable Constants,  Up: Important Language Features

2.3.7.6 Naming conventions
..........................

Ruby enforces some naming conventions.  If an identifier starts with a
capital letter, it is a constant.  If it starts with a dollar sign
('$'), it is a global variable.  If it starts with '@', it is an
instance variable.  If it starts with '@@', it is a class variable.

   Method names, however, are allowed to start with capital letters.
This can lead to confusion, as the example below shows:

     Constant = 10
     def Constant
       11
     end

   Now 'Constant' is 10, but 'Constant()' is 11.


File: Ruby2_5.info,  Node: Keyword arguments,  Next: The universal truth,  Prev: Naming conventions,  Up: Important Language Features

2.3.7.7 Keyword arguments
.........................

Like in Python, since Ruby 2.0 methods can be defined using keyword
arguments:

     def deliver(from: "A", to: nil, via: "mail")
       "Sending from #{from} to #{to} via #{via}."
     end

     deliver(to: "B")
     # => "Sending from A to B via mail."
     deliver(via: "Pony Express", from: "B", to: "A")
     # => "Sending from B to A via Pony Express."


File: Ruby2_5.info,  Node: The universal truth,  Next: Access modifiers are Methods,  Prev: Keyword arguments,  Up: Important Language Features

2.3.7.8 The universal truth
...........................

In Ruby, everything except 'nil' and 'false' is considered true.  In
C, Python and many other languages, '0' and possibly other values,
such as empty lists, are considered false.  Take a look at the
following Python code (the example applies to other languages, too):

     # in Python
     if 0:
       print("0 is true")
     else:
       print("0 is false")

   This will print '“0 is false”'.  The equivalent Ruby:

     # in Ruby
     if 0
       puts "0 is true"
     else
       puts "0 is false"
     end

   Prints '“0 is true”'.


File: Ruby2_5.info,  Node: Access modifiers are Methods,  Next: Method access,  Prev: The universal truth,  Up: Important Language Features

2.3.7.9 Access modifiers are Methods
....................................

Access modifiers apply until the end of scope.

   In the following Ruby code,

     class MyClass
       private
       def a_method; true; end
       def another_method; false; end
     end

   You might expect 'another_method' to be public.  Not so.  The
'private' access modifier continues until the end of the scope, or
until another access modifier pops up, whichever comes first.  By
default, methods are public:

     class MyClass
       # Now a_method is public
       def a_method; true; end

       private

       # another_method is private
       def another_method; false; end
     end

   * 'public',
   * 'private' and
   * 'protected'

   are really methods, so they can take parameters.  If you pass a
Symbol to one of them, that method’s visibility is altered.


File: Ruby2_5.info,  Node: Method access,  Next: Classes are open,  Prev: Access modifiers are Methods,  Up: Important Language Features

2.3.7.10 Method access
......................

In Java, 'public' means a method is accessible by anyone.  'protected'
means the class's instances, instances of descendant classes, and
instances of classes in the same package can access it, but not anyone
else; and 'private' means nobody besides the class's instances can
access the method.

   Ruby differs slightly.  'public' is, naturally, public.  'private'
means the method(s) are accessible only when they can be called
without an explicit receiver.  Only 'self' is allowed to be the
receiver of a private method call.

   'protected' is the one to be on the lookout for.  A 'protected'
method can be called from a class or descendant class instances, but
also with another instance as its receiver.  Here is an example
(adapted from The Ruby Language FAQ):

     class Test
       # public by default
       def identifier
         99
       end

       def ==(other)
         identifier == other.identifier
       end
     end

     t1 = Test.new  # => #<Test:0x34ab50>
     t2 = Test.new  # => #<Test:0x342784>
     t1 == t2       # => true

     # now make `identifier' protected; it still works
     # because protected allows `other' as receiver

     class Test
       protected :identifier
     end

     t1 == t2  # => true

     # now make `identifier' private

     class Test
       private :identifier
     end

     t1 == t2
     # NoMethodError: private method `identifier' called for #<Test:0x342784>


File: Ruby2_5.info,  Node: Classes are open,  Next: Funny method names,  Prev: Method access,  Up: Important Language Features

2.3.7.11 Classes are open
.........................

Ruby classes are open.  You can open them up, add to them, and change
them at any time.  Even core classes, like 'Fixnum' or even 'Object',
the parent of all objects.  Ruby on Rails defines a bunch of methods
for dealing with time on 'Fixnum'.  Watch:

     class Fixnum
       def hours
         self * 3600 # number of seconds in an hour
       end
       alias hour hours
     end

     # 14 hours from 00:00 January 1st
     # (aka when you finally wake up ;)
     Time.mktime(2006, 01, 01) + 14.hours # => Sun Jan 01 14:00:00


File: Ruby2_5.info,  Node: Funny method names,  Next: Singleton methods,  Prev: Classes are open,  Up: Important Language Features

2.3.7.12 Funny method names
...........................

In Ruby, methods are allowed to end with question marks or exclamation
marks.  By convention, methods that answer questions end in question
marks (e.g.  'Array#empty?', which returns 'true' if the receiver is
empty).  Potentially "dangerous" methods by convention end with
exclamation marks (e.g.  methods that modify 'self' or the arguments,
'exit!', etc.).  Not all methods that change their arguments end with
exclamation marks, though.  'Array#replace' replaces the contents of
an array with the contents of another array.  It doesn’t make much
sense to have a method like that that doesn't modify self.


File: Ruby2_5.info,  Node: Singleton methods,  Next: Missing methods,  Prev: Funny method names,  Up: Important Language Features

2.3.7.13 Singleton methods
..........................

"Singleton methods" are per-object methods.  They are only available
on the Object you defined it on.

     class Car
       def inspect
         "Cheap car"
       end
     end

     porsche = Car.new
     porsche.inspect # => Cheap car
     def porsche.inspect
       "Expensive car"
     end

     porsche.inspect # => Expensive car

     # Other objects are not affected
     other_car = Car.new
     other_car.inspect # => Cheap car


File: Ruby2_5.info,  Node: Missing methods,  Next: Message passing --- not function calls,  Prev: Singleton methods,  Up: Important Language Features

2.3.7.14 Missing methods
........................

Ruby doesn't give up if it can't find a method that responds to a
particular message.  It calls the 'method_missing' method with the
name of the method it couldn't find and the arguments.  By default,
'method_missing' raises a 'NameError' exception, but you can redefine
it to better fit your application, and many libraries do.  Here is an
example:

     # id is the name of the method called, the * syntax collects
     # all the arguments in an array named 'arguments'
     def method_missing(id, *arguments)
       puts "Method #{id} was called, but not found. It has " +
            "these arguments: #{arguments.join(", ")}"
     end

     __ :a, :b, 10
     # => Method __ was called, but not found. It has these
     # arguments: a, b, 10

   The code above just prints the details of the call, but you are
free to handle the message in any way that is appropriate.


File: Ruby2_5.info,  Node: Message passing --- not function calls,  Next: Blocks are Objects,  Prev: Missing methods,  Up: Important Language Features

2.3.7.15 Message passing, not function calls
............................................

A method call is really a "message" to another object:

     # This
     1 + 2
     # Is the same as this ...
     1.+(2)
     # Which is the same as this:
     1.send "+", 2


File: Ruby2_5.info,  Node: Blocks are Objects,  Next: Operators are syntactic sugar,  Prev: Message passing --- not function calls,  Up: Important Language Features

2.3.7.16 Blocks are Objects
...........................

Blocks (closures, really) are heavily used by the standard library.
To call a block, you can either use 'yield', or make it a 'Proc' by
appending a special argument to the argument list, like so:

     def block(&the_block)
       # Inside here, the_block is the block passed to the method
       the_block # return the block
     end
     adder = block { |a, b| a + b }
     # adder is now a Proc object
     adder.class # => Proc

   You can create blocks outside of method calls, too, by calling
'Proc.new' with a block or calling the 'lambda' method.

   Similarly, methods are also Objects in the making:

     method(:puts).call "puts is an object!"
     # => puts is an object!


File: Ruby2_5.info,  Node: Operators are syntactic sugar,  Prev: Blocks are Objects,  Up: Important Language Features

2.3.7.17 Operators are syntactic sugar
......................................

Most operators in Ruby are just syntactic sugar (with some precedence
rules) for method calls.  You can, for example, override 'Fixnum'’s
'+' method:

     class Fixnum
       # You can, but please don't do this
       def +(other)
         self - other
       end
     end

   You don’t need C++'s 'operator+', etc.

   You can even have array-style access if you define the '[]' and
'[]=' methods.  To define the unary '+' and '-' (think '+1' and '-2'),
you must define the '+@' and '-@' methods, respectively.  The
operators below are not syntactic sugar, though.  They are not
methods, and cannot be redefined:

     =, .., ..., not, &&, and, ||, or, ::

   In addition, '+=, *=' etc.  are just abbreviations for 'var = var +
other_var', 'var = var * other_var', etc.  and therefore cannot be
redefined.


File: Ruby2_5.info,  Node: Learning Ruby,  Next: Ruby Essentials,  Prev: Important Language Features,  Up: Getting Started

2.3.8 Learning Ruby
-------------------

Learning Ruby (http://rubylearning.com/)

   A thorough collection of Ruby study notes for those who are new to
the language and in search of a solid introduction to Ruby’s concepts
and constructs.


File: Ruby2_5.info,  Node: Ruby Essentials,  Next: Learn to Program,  Prev: Learning Ruby,  Up: Getting Started

2.3.9 Ruby Essentials
---------------------

Ruby Essentials (http://www.techotopia.com/index.php/Ruby_Essentials)


File: Ruby2_5.info,  Node: Learn to Program,  Prev: Ruby Essentials,  Up: Getting Started

2.3.10 Learn to Program
-----------------------

Learn to Program (http://pine.fm/LearnToProgram/)

   A wonderful little tutorial by Chris Pine for programming newbies.
If you don’t know how to program, start here.

   Learn Ruby the Hard Way (http://ruby.learncodethehardway.org/)


File: Ruby2_5.info,  Node: Manuals,  Next: Reference Documentation,  Prev: Getting Started,  Up: Documentation

2.4 Manuals
===========

* Menu:

* Ruby User's Guide::
* Programming Ruby::


File: Ruby2_5.info,  Node: Ruby User's Guide,  Next: Programming Ruby,  Up: Manuals

2.4.1 Ruby User's Guide
-----------------------

Translated from the original Japanese version written by Yukihiro
Matsumoto (the creator of Ruby), this version, by Goto Kentaro and
Mark Slagell, is a nice overview of many aspects of the Ruby language.

   Ruby User's Guide (http://www.rubyist.net/~slagell/ruby/)

* Menu:

* What Is Ruby?::
* Simple Examples::


File: Ruby2_5.info,  Node: What Is Ruby?,  Next: Simple Examples,  Up: Ruby User's Guide

2.4.1.1 What Is Ruby?
.....................

Ruby is "an interpreted scripting language for quick and easy
object-oriented programming" -- what does this mean?

interpreted scripting language:
        * ability to make operating system calls directly
        * powerful string operations and regular expressions
        * immediate feedback during development

quick and easy:
        * variable declarations are unnecessary
        * variables are not typed
        * syntax is simple and consistent
        * memory management is automatic

object oriented programming:
        * everything is an object
        * classes, methods, inheritance, etc.
        * singleton methods
        * "mixin" functionality by module
        * iterators and closures

also:
        * multiple precision integers
        * convenient exception processing
        * dynamic loading
        * threading support


File: Ruby2_5.info,  Node: Simple Examples,  Prev: What Is Ruby?,  Up: Ruby User's Guide

2.4.1.2 Simple Examples
.......................

Factorial in Ruby
-----------------

Let's write a function to compute factorials.  The mathematical
definition of "n factorial" is:

     n! = 1                (when n==0)
        = n * (n-1)!       (otherwise)

   In ruby, this can be written as:

{'fact.rb'} ==
     # Program to find the factorial of a number
     # Save this as fact.rb

     def fact(n)
       if n == 0
         1
       else
         n * fact(n-1)
       end
     end

     puts fact(ARGV[0].to_i)


Command Line Arguments -- In Array ARGV
.......................................

'ARGV' is an array which contains the command line arguments, and
'to_i' converts a character string to an integer.

The 'end' Statement
...................

You may notice the repeated occurrence of 'end'.  Ruby has been called
"Algol-like" because of this.  (Actually, the syntax of ruby more
closely mimics that of a langage named Eiffel
(https://www.eiffel.org/).)

Takeaway -- 'return' Statement Optional
.......................................

You may also notice the lack of a 'return' statement.

     [A 'return' statement] is unneeded because *a ruby function
     returns the last thing that was evaluated in it*.  Use of a
     'return' statement here is permissible but unnecessary.

Running 'fact.rb'
.................

Ruby can deal with any integer which is allowed by your machine's
memory.  So 400!  can be calculated:

     % ruby fact.rb 1
     1
     % ruby fact.rb 5
     120

     % ruby fact.rb 40
     815915283247897734345611269596115894272000000000

     % ruby fact.rb 400
     64034522846623895262347970319503005850702583026002959458684
     44594280239716918683143627847864746326467629435057503585681
     08482981628835174352289619886468029979373416541508381624264
     61942352307046244325015114448670890662773914918117331955996
     44070954967134529047702032243491121079759328079510154537266
     72516278778900093497637657103263503315339653498683868313393
     52024373788157786791506311858702618270169819740062983025308
     59129834616227230455833952075961150530223608681043329725519
     48526744322324386699484224042325998055516106359423769613992
     31917134063858996537970147827206606320217379472010321356624
     61380907794230459736069956759583609615871512991382228657857
     95493616176544804532220078258184008484364155912294542753848
     03558374518022675900061399560145595206127211192918105032491
     00800000000000000000000000000000000000000000000000000000000
     0000000000000000000000000000000000000000000


File: Ruby2_5.info,  Node: Programming Ruby,  Prev: Ruby User's Guide,  Up: Manuals

2.4.2 Programming Ruby
----------------------

The Programmatic Programmer's Guide
-----------------------------------

Programming Ruby (http://ruby-doc.com/docs/ProgrammingRuby/)

What This Book Is
.................

This book is a tutorial and reference for the Ruby programming
language.  Use Ruby, and you'll write better code, be more productive,
and enjoy programming more.

What Ruby Is
............

Take a true object-oriented language, such as Smalltalk.  Drop the
unfamiliar syntax and move to more conventional, file-based source
code.  Now add in a good measure of the flexibility and convenience of
languages such as Python and Perl.

   You end up with Ruby.

Ruby is OO
..........

OO aficionados will find much to like in Ruby: things such as pure
object orientation (everything's an object), metaclasses, closures,
iterators, and ubiquitous heterogeneous collections.  Smalltalk users
will feel right at home (and C++ and Java users will feel jealous).

Ruby is Perl and Python
.......................

At the same time, Perl and Python wizards will find many of their
favorite features: full regular expression support, tight integration
with the underlying operating system, convenient shortcuts, and
dynamic evaluation.

Principle of Lease Surprise
...........................

Ruby follows the Principle of Least Surprise -- things work the way
you would expect them to, with very few special cases or exceptions.

Ruby is a "Transparent" Language
................................

We call Ruby a "transparent" language.  By that we mean that Ruby
doesn't obscure the solutions you write behind lots of syntax and the
need to churn out reams of support code just to get simple things
done.  With Ruby you write programs close to the problem domain.
Rather than constantly mapping your ideas and designs down to the
pedestrian level of most languages, with Ruby you'll find you can
express them directly and express them elegantly.  This means you code
faster.  It also means your programs stay readable and maintainable.

Ruby is a "Scripting" Language
..............................

What exactly is a scripting language?  Frankly we don't know if it's a
distinction worth making.  In Ruby, you can access all the underlying
operating system features.  You can do the same stuff in Ruby that you
can in Perl or Python, and you can do it more cleanly.  But Ruby is
fundamentally different.  It is a true programming language, too, with
strong theoretical roots and an elegant, lightweight syntax.  You
could hack together a mess of "scripts" with Ruby, but you probably
won't.  Instead, you'll be more inclined to engineer a solution, to
produce a program that is easy to understand, simple to maintain, and
a piece of cake to extend and reuse in the future.

Ruby is a General Purpose Programming Language
..............................................

Although we have used Ruby for scripting jobs, most of the time we use
it as a general-purpose programming language.  We've used it to write
GUI applications and middle-tier server processes, and we're using it
to format large parts of this book.  Others have used it for managing
server machines and databases.  Ruby is serving Web pages, interfacing
to databases and generating dynamic content.  People are writing
artificial intelligence and machine learning programs in Ruby, and at
least one person is using it to investigate natural evolution.  Ruby's
finding a home as a vehicle for exploratory mathematics.  And people
all over the world are using it as a way of gluing together all their
different applications.  It truly is a great language for producing
solutions in a wide variety of problem domains.

Should I Use Ruby?
..................

However, Ruby is probably more applicable than you might think.  It is
easy to extend, both from within the language and by linking in
third-party libraries.  It is portable across a number of platforms.
It's relatively lightweight and consumes only modest system resources.
And it's easy to learn; we've known people who've put Ruby code into
production systems within a day of picking up drafts of this book.
We've used Ruby to implement parts of an X11 window manager, a task
that's normally considered severe C coding.  Ruby excelled, and helped
us write code in hours that would otherwise have taken days.


File: Ruby2_5.info,  Node: Reference Documentation,  Next: Editors and IDEs,  Prev: Manuals,  Up: Documentation

2.5 Reference Documentation
===========================


File: Ruby2_5.info,  Node: Editors and IDEs,  Next: Further Reading,  Prev: Reference Documentation,  Up: Documentation

2.6 Editors and IDEs
====================


File: Ruby2_5.info,  Node: Further Reading,  Prev: Editors and IDEs,  Up: Documentation

2.7 Further Reading
===================


File: Ruby2_5.info,  Node: The Makefile,  Next: Code Chunk Summaries,  Prev: Documentation,  Up: Top

Appendix A The Makefile
***********************

{'Makefile'} ==
     <Makefile--Variable Definitions> <Makefile--Default Rule>
     <Makefile--TWJR Rules> <Makefile--Clean Rules>

The following table lists called chunk definition points.
Chunk name                First definition point
-------------------------------------------------------------------------
<Makefile--Clean Rules>   See *note Makefile---Clean-Rules::.
<Makefile--Default        See *note Makefile---Default-Rule::.
Rule>
<Makefile--TWJR Rules>    See *note Makefile---TWJR-Rules::.
<Makefile--Variable       See *note Makefile---Variable-Definitions::.
Definitions>

* Menu:

* Makefile Variable Definitions::
* Makefile Default Rule::
* Makefile TWJR Rules::
* Makefile Clean Rules::


File: Ruby2_5.info,  Node: Makefile Variable Definitions,  Next: Makefile Default Rule,  Up: The Makefile

A.1 Makefile Variable Definitions
=================================

<Makefile--Variable Definitions> ==
     FILE := Ruby2_5
     SHELL := /bin/bash


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: Ruby2_5.info,  Node: Makefile Default Rule,  Next: Makefile TWJR Rules,  Prev: Makefile Variable Definitions,  Up: The Makefile

A.2 Default Rule
================

The 'default' rule is to create a PDF document and all HTML files.
This assumes that the TEXI file has been generated and updated by hand
first.  Therefore, the target 'TWJR' will run both 'jrtangle' and
'jrweave', while the target 'WEAVE' or alternatively 'TEXI' will run
just 'jrweave' on the '.twjr' file.  Thereafter, you can update the
'.texi' file and run the 'default'.

<Makefile--Default Rule> ==
     .PHONY : default TWJR TANGLE WEAVE TEXI PDF HTML
     .PHONY : twjr tangle weave texi pdf html
     default : PDF HTML


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: Ruby2_5.info,  Node: Makefile TWJR Rules,  Next: Makefile Clean Rules,  Prev: Makefile Default Rule,  Up: The Makefile

A.3 TWJR Rules
==============

<Makefile--TWJR Rules> ==
     TWJR : twjr
     twjr : tangle weave

     TANGLE : tangle
     tangle : $(FILE).twjr
         jrtangle $(FILE).twjr

     WEAVE : weave
     weave : TEXI
     TEXI  : texi
     texi  : $(FILE).texi

     $(FILE).texi : $(FILE).twjr
         jrweave $(FILE).twjr > $(FILE).texi

     PDF : pdf
     pdf : $(FILE).pdf
     $(FILE).pdf : $(FILE).texi
         pdftexi2dvi $(FILE).texi
         make distclean

     HTML : html
     html : $(FILE)/
     $(FILE)/ : $(FILE).texi
         makeinfo --html $(FILE).texi


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: Ruby2_5.info,  Node: Makefile Clean Rules,  Prev: Makefile TWJR Rules,  Up: The Makefile

A.4 Clean Rules
===============

<Makefile--Clean Rules> ==
     .PHONY : clean distclean veryclean worldclean
     clean :
         rm -f *~ \#*\#

     distclean : clean
         rm -f *.{aux,log,toc,cp,cps}

     veryclean : clean
         for file in *; do [[ $$file =~ $(FILE)|Makefile ]] && : || rm -vrf $$file ; done;

     worldclean : veryclean
         rm -fr $(FILE).{texi,info,pdf} $(FILE)/


This chunk is called by {'Makefile'}; see its first definition at
*note Makefile::.


File: Ruby2_5.info,  Node: Code Chunk Summaries,  Next: Bibliography,  Prev: The Makefile,  Up: Top

Appendix B Code Chunk Summaries
*******************************

This major node presents alphabetical lists of all the file
definitions, the code chunk definitions, and the code chunk
references.

* Menu:

* File Definitions::
* Code Chunk Definitions::
* Code Chunk References::


File: Ruby2_5.info,  Node: File Definitions,  Next: Code Chunk Definitions,  Up: Code Chunk Summaries

B.1 Source File Definitions
===========================

{'Makefile'}
     This chunk is defined in *note Makefile::.
{'fact.rb'}
     This chunk is defined in *note fact-rb::.
{'ri20min.rb'}
     This chunk is defined in *note ri20min-rb::.


File: Ruby2_5.info,  Node: Code Chunk Definitions,  Next: Code Chunk References,  Prev: File Definitions,  Up: Code Chunk Summaries

B.2 Code Chunk Definitions
==========================

<Makefile--Clean Rules>
     This chunk is defined in *note Makefile---Clean-Rules::.
<Makefile--Default Rule>
     This chunk is defined in *note Makefile---Default-Rule::.
<Makefile--TWJR Rules>
     This chunk is defined in *note Makefile---TWJR-Rules::.
<Makefile--Variable Definitions>
     This chunk is defined in *note Makefile---Variable-Definitions::.
<MegaGreeter--Initialize Method>
     This chunk is defined in *note MegaGreeter---Initialize-Method::.
<MegaGreeter--Main Script>
     This chunk is defined in *note MegaGreeter---Main-Script::.
<MegaGreeter--say_bye Method>
     This chunk is defined in *note MegaGreeter---say-bye-Method::.
<MegaGreeter--say_hi Method>
     This chunk is defined in *note MegaGreeter---say-hi-Method::.


File: Ruby2_5.info,  Node: Code Chunk References,  Prev: Code Chunk Definitions,  Up: Code Chunk Summaries

B.3 Code Chunk References
=========================

<Makefile--Clean Rules>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Makefile--Default Rule>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Makefile--TWJR Rules>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<Makefile--Variable Definitions>

     This chunk is called by {'Makefile'}; see its first definition at
     *note Makefile::.
<MegaGreeter--Initialize Method>

     This chunk is called by {'ri20min.rb'}; see its first definition
     at *note ri20min-rb::.
<MegaGreeter--Main Script>

     This chunk is called by {'ri20min.rb'}; see its first definition
     at *note ri20min-rb::.
<MegaGreeter--say_bye Method>

     This chunk is called by {'ri20min.rb'}; see its first definition
     at *note ri20min-rb::.
<MegaGreeter--say_hi Method>

     This chunk is called by {'ri20min.rb'}; see its first definition
     at *note ri20min-rb::.


File: Ruby2_5.info,  Node: Bibliography,  Next: Concept Index,  Prev: Code Chunk Summaries,  Up: Top

Bibliography
************


File: Ruby2_5.info,  Node: Concept Index,  Prev: Bibliography,  Up: Top

Index
*****

 [index ]
* Menu:

* "#symbol":                             FAQ Syntax.        (line 115)
* "falsey" values:                       FAQ Syntax.        (line  59)
* "name".intern:                         FAQ Syntax.        (line  83)
* "name".to_sym:                         FAQ Syntax.        (line  83)
* "truthy" values:                       FAQ Syntax.        (line  59)
* ++ and --:                             FAQ Methods.       (line  15)
* .. vs. ...:                            FAQ Syntax.        (line 203)
* <Makefile--Clean Rules>, definition:   Makefile Clean Rules.
                                                            (line   6)
* <Makefile--Clean Rules>, use:          The Makefile.      (line   6)
* <Makefile--Default Rule>, definition:  Makefile Default Rule.
                                                            (line  13)
* <Makefile--Default Rule>, use:         The Makefile.      (line   6)
* <Makefile--TWJR Rules>, definition:    Makefile TWJR Rules.
                                                            (line   6)
* <Makefile--TWJR Rules>, use:           The Makefile.      (line   6)
* <Makefile--Variable Definitions>, definition: Makefile Variable Definitions.
                                                            (line   6)
* <Makefile--Variable Definitions>, use: The Makefile.      (line   6)
* <MegaGreeter--Initialize Method>, definition: Large Class Definition.
                                                            (line  41)
* <MegaGreeter--Initialize Method>, use: Large Class Definition.
                                                            (line  10)
* <MegaGreeter--Main Script>, definition: Large Class Definition.
                                                            (line 162)
* <MegaGreeter--Main Script>, use:       Large Class Definition.
                                                            (line  10)
* <MegaGreeter--say_bye Method>, definition: Large Class Definition.
                                                            (line 131)
* <MegaGreeter--say_bye Method>, use:    Large Class Definition.
                                                            (line  10)
* <MegaGreeter--say_hi Method>, definition: Large Class Definition.
                                                            (line  63)
* <MegaGreeter--say_hi Method>, use:     Large Class Definition.
                                                            (line  10)
* == vs equals():                        To Ruby From Java. (line  59)
* \Z:                                    FAQ Built-In Libraries.
                                                            (line  54)
* __FILE__ special variable:             Large Class Definition.
                                                            (line 151)
* {fact.rb}, definition:                 Simple Examples.   (line  17)
* {Makefile}, definition:                The Makefile.      (line   6)
* {ri20min.rb}, definition:              Large Class Definition.
                                                            (line  10)
* access control:                        To Ruby From Java. (line  36)
* access modifier scope:                 Access modifiers are Methods.
                                                            (line   6)
* access modifiers public, private, protected: Access modifiers are Methods.
                                                            (line   6)
* Algol and Ruby:                        Simple Examples.   (line  54)
* ArgumentError, after calling super:    FAQ Methods.       (line  39)
* arithmetic:                            FAQ Extension Library.
                                                            (line  26)
* Array:                                 To Ruby From C and C++.
                                                            (line 155)
* array literals in brackets:            To Ruby From C and C++.
                                                            (line 114)
* array, sum elements in:                FAQ Other Features.
                                                            (line  18)
* arrays are dynamic and mutable:        To Ruby From C and C++.
                                                            (line 116)
* arrays, adding:                        To Ruby From C and C++.
                                                            (line 119)
* attributes:                            To Ruby From C and C++.
                                                            (line 137)
* attr_accessor :name:                   Altering Classes.  (line   9)
* attr_accessor, methods defined:        Altering Classes.  (line  41)
* binary Ruby extension modules:         FAQ Syntax.        (line 249)
* binding of { ... }:                    FAQ Iterators.     (line  36)
* binding.local_variable_get(:symbol):   FAQ Syntax.        (line 127)
* block:                                 Large Class Definition.
                                                            (line  85)
* block <1>:                             To Ruby From C and C++.
                                                            (line 106)
* block for iterator:                    To Ruby From C and C++.
                                                            (line 154)
* block object, passed to iterator:      FAQ Iterators.     (line   9)
* block, used in an iterator:            FAQ Iterators.     (line  56)
* blocks:                                Blocks are Objects.
                                                            (line   6)
* block_given?:                          FAQ Iterators.     (line 112)
* boolean context:                       FAQ Syntax.        (line  59)
* braces, none:                          To Ruby From C and C++.
                                                            (line 101)
* branches page:                         Branches Page.     (line   6)
* C library, use:                        FAQ Extension Library.
                                                            (line  15)
* calling method 2 levels up:            FAQ Methods.       (line  42)
* case conventions, enforced:            To Ruby From C and C++.
                                                            (line 144)
* cast:                                  To Ruby From C and C++.
                                                            (line 149)
* casting, none:                         To Ruby From Java. (line  49)
* chruby:                                chruby.            (line   6)
* class definition:                      Defining Methods.  (line  70)
* class definition, repeating:           FAQ Classes and Modules.
                                                            (line   9)
* class instance variable?:              FAQ Classes and Modules.
                                                            (line  15)
* class keyword:                         Defining Methods.  (line  70)
* class methods, defining, 2 ways:       FAQ Classes and Modules.
                                                            (line  39)
* class methods?:                        FAQ Classes and Modules.
                                                            (line  21)
* class variable @@:                     Naming conventions.
                                                            (line   9)
* class variables vs class instance variables: FAQ Classes and Modules.
                                                            (line  18)
* class variables?:                      FAQ Classes and Modules.
                                                            (line  12)
* class vs module:                       FAQ Classes and Modules.
                                                            (line  30)
* classes, modifying:                    Altering Classes.  (line  19)
* classes, open:                         Classes are open.  (line   6)
* collect:                               Pointers on Iteration.
                                                            (line  17)
* command line arguments in ARGV:        Simple Examples.   (line  35)
* conditional expression, false values:  FAQ Syntax.        (line  73)
* constant naming convention:            Naming conventions.
                                                            (line   9)
* constructor:                           To Ruby From C and C++.
                                                            (line 131)
* constructor <1>:                       To Ruby From Java. (line  52)
* container types:                       To Ruby From C and C++.
                                                            (line 155)
* continuations, using:                  FAQ Other Features.
                                                            (line  20)
* conventions, naming:                   Naming conventions.
                                                            (line   6)
* dangerous, destructive methods:        FAQ Methods.       (line  51)
* debugger for Ruby:                     FAQ Extension Library.
                                                            (line  12)
* def:                                   Defining Methods.  (line   6)
* destructive method:                    FAQ Methods.       (line  48)
* developing Ruby:                       Developing Ruby.   (line   6)
* DLLs:                                  FAQ Syntax.        (line 249)
* do ... } while:                        FAQ Syntax.        (line 156)
* do keyword:                            To Ruby From C and C++.
                                                            (line 103)
* doc tools:                             To Ruby From Perl. (line  30)
* doc tools <1>:                         To Ruby From Python.
                                                            (line  29)
* Documentation:                         Documentation.     (line   6)
* documentation tool:                    To Ruby From Java. (line  23)
* duck typing:                           Large Class Definition.
                                                            (line 123)
* dynamicly typed:                       To Ruby From C and C++.
                                                            (line  28)
* each:                                  Pointers on Iteration.
                                                            (line  17)
* each method of iterator:               FAQ Iterators.     (line  25)
* Eiffel and Ruby:                       Simple Examples.   (line  54)
* empty string:                          FAQ Syntax.        (line  73)
* ensure clause:                         FAQ Syntax.        (line 265)
* equivalence vs the same:               To Ruby From Java. (line  59)
* eval:                                  FAQ Syntax.        (line 115)
* exception handling:                    FAQ Syntax.        (line 254)
* extension modules:                     To Ruby From C and C++.
                                                            (line  36)
* factorial in Ruby:                     Simple Examples.   (line   9)
* false and nil:                         FAQ Syntax.        (line  59)
* FalseClass:                            FAQ Syntax.        (line  64)
* File object, no reference:             FAQ Built-In Libraries.
                                                            (line  30)
* file, copy:                            FAQ Built-In Libraries.
                                                            (line  21)
* file, count lines in:                  FAQ Other Features.
                                                            (line  12)
* file, line number:                     FAQ Built-In Libraries.
                                                            (line  24)
* file, process and update contents:     FAQ Built-In Libraries.
                                                            (line  18)
* files, closing:                        FAQ Built-In Libraries.
                                                            (line  33)
* files, counting words:                 FAQ Built-In Libraries.
                                                            (line  39)
* files, reading vs modifying:           FAQ Built-In Libraries.
                                                            (line  15)
* files, sorting by modification time:   FAQ Built-In Libraries.
                                                            (line  36)
* find:                                  Pointers on Iteration.
                                                            (line  17)
* fork vs thread:                        FAQ Built-In Libraries.
                                                            (line  57)
* function pointers:                     FAQ Syntax.        (line 237)
* function-like methods, where from?:    FAQ Methods.       (line  24)
* FXRuby:                                To Ruby From Java. (line  31)
* garbage collector:                     To Ruby From Java. (line  18)
* gemsets, manage different using RVM:   RVM (``Ruby Version Manager'').
                                                            (line   6)
* GitHub, ruby repository:               Developing Ruby.   (line  54)
* global variable $:                     Naming conventions.
                                                            (line   9)
* green threads vs native threads:       To Ruby From C and C++.
                                                            (line 160)
* gtk+:                                  FAQ Extension Library.
                                                            (line  24)
* GUI toolkits:                          To Ruby From Java. (line  31)
* Hash:                                  To Ruby From C and C++.
                                                            (line 155)
* heap:                                  To Ruby From C and C++.
                                                            (line  89)
* identifier with capital letter, method?: FAQ Methods.     (line  36)
* immediate values:                      FAQ Syntax.        (line  46)
* import:                                To Ruby From Java. (line  34)
* include vs extend:                     FAQ Classes and Modules.
                                                            (line  42)
* initialize method:                     Large Class Definition.
                                                            (line  41)
* initialize, constructor:               To Ruby From Java. (line  52)
* inject:                                Pointers on Iteration.
                                                            (line  17)
* insert code into a string:             Defining Methods.  (line  43)
* installer, third party:                Installers.        (line   6)
* instance variable:                     Defining Methods.  (line  86)
* instance variable @:                   Naming conventions.
                                                            (line   9)
* instance variables, accessing:         FAQ Methods.       (line  27)
* instance variables, encapsulation:     Defining Methods.  (line 109)
* instance_methods(false):               FAQ Built-In Libraries.
                                                            (line   9)
* interactively use Ruby:                FAQ Extension Library.
                                                            (line   9)
* interfaces, none, use mixins:          To Ruby From Java. (line  53)
* invoking original method after redefinition: FAQ Methods. (line  45)
* irb:                                   Interactive Ruby.  (line   6)
* irb <1>:                               To Ruby From Python.
                                                            (line  13)
* issue tracker:                         Developing Ruby.   (line  62)
* issue tracking:                        Issue Tracking.    (line   6)
* iteration:                             To Ruby From C and C++.
                                                            (line 154)
* iteration <1>:                         Pointers on Iteration.
                                                            (line   6)
* iterator:                              Large Class Definition.
                                                            (line  85)
* iterator method:                       To Ruby From C and C++.
                                                            (line 154)
* iterator, block:                       FAQ Iterators.     (line  56)
* iterators:                             FAQ Iterators.     (line   6)
* javadoc:                               To Ruby From Java. (line  23)
* join method, respond to:               Large Class Definition.
                                                            (line 116)
* Kernel:                                FAQ Syntax.        (line 149)
* lambda as a synonym of Proc:           FAQ Iterators.     (line  87)
* lambda method:                         Blocks are Objects.
                                                            (line  19)
* line number of input file:             FAQ Built-In Libraries.
                                                            (line  24)
* load:                                  FAQ Syntax.        (line 245)
* loop:                                  FAQ Syntax.        (line 149)
* mailing lists:                         Developing Ruby.   (line  62)
* manage Rubies using chruby:            chruby.            (line   6)
* Marshal:                               FAQ Built-In Libraries.
                                                            (line  60)
* MatchData#begin and MatchData#end:     FAQ Other Features.
                                                            (line  15)
* member variables, access to:           To Ruby From C and C++.
                                                            (line 137)
* memory management:                     To Ruby From Java. (line  18)
* method parameters:                     Defining Methods.  (line  33)
* method, destructive:                   FAQ Methods.       (line  48)
* method, invoking:                      FAQ Methods.       (line   9)
* method, invoking <1>:                  Defining Methods.  (line  26)
* methods are virtual:                   To Ruby From C and C++.
                                                            (line 132)
* methods, defining:                     Defining Methods.  (line   6)
* method_missing method:                 Missing methods.   (line   6)
* mixin example:                         FAQ Classes and Modules.
                                                            (line  36)
* mixins:                                To Ruby From C and C++.
                                                            (line 142)
* mixins <1>:                            To Ruby From Java. (line  53)
* module function?:                      FAQ Classes and Modules.
                                                            (line  27)
* modules, subclassing?:                 FAQ Classes and Modules.
                                                            (line  33)
* multiple inheritance:                  To Ruby From C and C++.
                                                            (line 142)
* multiple installations, manage using RVM: RVM (``Ruby Version Manager'').
                                                            (line   6)
* multiple Rubies, command-line tool uru: uru.              (line   6)
* multithreading:                        To Ruby From C and C++.
                                                            (line 160)
* nil and false, similariaties and differences: FAQ Syntax. (line  59)
* nil vs null:                           To Ruby From Java. (line  55)
* NilClass:                              FAQ Syntax.        (line  64)
* null vs nil:                           To Ruby From Java. (line  55)
* object reference is self:              To Ruby From C and C++.
                                                            (line 138)
* Object#instance_methods:               Defining Methods.  (line 116)
* Object#respond_to?:                    Defining Methods.  (line 146)
* object, create from class definition:  Defining Methods.  (line  95)
* objects, everything including numbers: To Ruby From Java. (line  40)
* objects, strongly and dynamically typed: To Ruby From C and C++.
                                                            (line 129)
* objects, strongly typed:               To Ruby From Java. (line  19)
* object_id methods:                     Symbols are not lightweight Strings.
                                                            (line  21)
* operators?:                            FAQ Methods.       (line  12)
* parameters, methods:                   Defining Methods.  (line  33)
* parentheses, none for condition expressions: To Ruby From C and C++.
                                                            (line  98)
* parentheses, optional:                 Defining Methods.  (line  26)
* parentheses, optional <1>:             Defining Methods.  (line  60)
* parentheses, optional for method calls: To Ruby From C and C++.
                                                            (line 100)
* parentheses, optional in method calls: To Ruby From Java. (line  38)
* Patch Writer's Guide:                  Developing Ruby.   (line  73)
* patching of Ruby:                      Developing Ruby.   (line  38)
* precedence of or:                      FAQ Syntax.        (line 211)
* precedence, iterators, different results: FAQ Iterators.  (line  36)
* predicate methods:                     FAQ Syntax.        (line  68)
* private vs protected:                  FAQ Methods.       (line  30)
* Proc:                                  Blocks are Objects.
                                                            (line   6)
* Proc object, passed to iterator:       FAQ Iterators.     (line   9)
* Proc.new, followed by call:            FAQ Iterators.     (line  87)
* program output, display using less:    FAQ Built-In Libraries.
                                                            (line  27)
* Qt:                                    To Ruby From Java. (line  31)
* random number seeds:                   FAQ Built-In Libraries.
                                                            (line  12)
* rbenv:                                 rbenv.             (line   6)
* rbenv version manager:                 ruby-build.        (line   6)
* RDoc:                                  To Ruby From Java. (line  23)
* rdoc:                                  To Ruby From Java. (line  23)
* rdoc <1>:                              To Ruby From Perl. (line  30)
* rdoc <2>:                              To Ruby From Python.
                                                            (line  29)
* regexes:                               To Ruby From Perl. (line  17)
* regular expression, escaping a backslash: FAQ Built-In Libraries.
                                                            (line  48)
* releases:                              Releases Page.     (line   6)
* repository, Subversion:                Developing Ruby.   (line  49)
* require:                               FAQ Syntax.        (line 245)
* require <1>:                           To Ruby From Java. (line  34)
* rescue clause:                         FAQ Syntax.        (line 265)
* respond to message, instance variable: Large Class Definition.
                                                            (line  54)
* respond_to? method:                    Large Class Definition.
                                                            (line  54)
* respository, GitHub:                   Developing Ruby.   (line  54)
* return mutliple values:                FAQ Methods.       (line  53)
* return statement unnecessary:          Simple Examples.   (line  54)
* ri:                                    Pointers on Iteration.
                                                            (line  24)
* Rubies, switch between:                Installers.        (line   6)
* Ruby core:                             Developing Ruby.   (line  16)
* Ruby Core mailing list:                Developing Ruby.   (line  62)
* Ruby development, tracking:            Developing Ruby.   (line  26)
* Ruby Tk:                               To Ruby From Java. (line  31)
* Ruby, what it is:                      What Is Ruby?.     (line   7)
* ruby-build plugin:                     ruby-build.        (line   6)
* Ruby-GNOME2:                           To Ruby From Java. (line  31)
* RVM version manager:                   Installers.        (line   6)
* scope, access modifiers:               Access modifiers are Methods.
                                                            (line   6)
* script code:                           Large Class Definition.
                                                            (line 151)
* self, meaning:                         FAQ Classes and Modules.
                                                            (line  44)
* self, object reference:                To Ruby From C and C++.
                                                            (line 138)
* send:                                  FAQ Syntax.        (line 129)
* shared libraries:                      FAQ Syntax.        (line 249)
* simple functions?:                     FAQ Methods.       (line  21)
* singleton class?:                      FAQ Classes and Modules.
                                                            (line  24)
* singleton method:                      FAQ Methods.       (line  18)
* singleton methods:                     Singleton methods. (line   6)
* sort:                                  Pointers on Iteration.
                                                            (line  17)
* source, building:                      Building From Source.
                                                            (line   6)
* static checking, none:                 To Ruby From Java. (line  41)
* statically typed:                      To Ruby From C and C++.
                                                            (line  28)
* String or Symbol:                      Symbols are not lightweight Strings.
                                                            (line  34)
* strings, sort alphabetically:          FAQ Built-In Libraries.
                                                            (line  42)
* strongly typed objects:                To Ruby From C and C++.
                                                            (line  80)
* sub vs sub!:                           FAQ Built-In Libraries.
                                                            (line  51)
* Subversion:                            Developing Ruby.   (line  26)
* Subversion repository:                 Developing Ruby.   (line  49)
* super gives ArgumentError:             FAQ Methods.       (line  39)
* sygils in Ruby:                        To Ruby From Perl. (line  41)
* Symbol:                                Symbols are not lightweight Strings.
                                                            (line  26)
* Symbol object:                         FAQ Syntax.        (line  83)
* Symbol or String:                      Symbols are not lightweight Strings.
                                                            (line  34)
* symbol, access value of:               FAQ Syntax.        (line 115)
* symbol.to_s:                           FAQ Syntax.        (line 115)
* symbols:                               Symbols are not lightweight Strings.
                                                            (line   6)
* symbols as enumeration values:         FAQ Syntax.        (line 105)
* symbols as hash keys:                  FAQ Syntax.        (line  99)
* symbols, unique constants:             FAQ Syntax.        (line 105)
* tabs, expand into spaces:              FAQ Built-In Libraries.
                                                            (line  45)
* Tcl/Tk, use:                           FAQ Extension Library.
                                                            (line  18)
* templates:                             To Ruby From C and C++.
                                                            (line 149)
* ternary operator:                      FAQ Other Features.
                                                            (line   9)
* Texinfo document formatting language:  Conventions.       (line   6)
* thread vs fork:                        FAQ Built-In Libraries.
                                                            (line  57)
* threads, native vs green:              To Ruby From C and C++.
                                                            (line 160)
* Tk, won't work:                        FAQ Extension Library.
                                                            (line  21)
* to_i method:                           Simple Examples.   (line  35)
* track Ruby development:                Developing Ruby.   (line  26)
* trap:                                  FAQ Built-In Libraries.
                                                            (line  62)
* truth values:                          To Ruby From C and C++.
                                                            (line 111)
* type conversions:                      To Ruby From C and C++.
                                                            (line 157)
* type declarations, none:               To Ruby From Java. (line  46)
* unit testing lib:                      To Ruby From C and C++.
                                                            (line 161)
* uru:                                   uru.               (line   6)
* value, everthing has one:              Everything has a value.
                                                            (line   6)
* variable, class @@:                    Naming conventions.
                                                            (line   9)
* variable, instance @:                  Naming conventions.
                                                            (line   9)
* varible, global $:                     Naming conventions.
                                                            (line   9)
* version managers:                      Installers.        (line   6)
* versions, multiple installations using rbenv: rbenv.      (line   6)
* versions, switch between using chruby: chruby.            (line   6)
* versions,multiple:                     Installers.        (line   6)
* visibility features:                   To Ruby From Java. (line  20)
* visibility, changing:                  FAQ Methods.       (line  33)
* WxRuby:                                To Ruby From Java. (line  31)
* xforms:                                FAQ Extension Library.
                                                            (line  24)
* XML vs YAML:                           To Ruby From Java. (line  54)
* YAML vs XML:                           To Ruby From Java. (line  54)
* yield:                                 Large Class Definition.
                                                            (line  85)
* yield <1>:                             Blocks are Objects.
                                                            (line   6)
* yield control structor, or statement:  FAQ Iterators.     (line  56)
* yield control structure in iterator:   FAQ Iterators.     (line  61)



Tag Table:
Node: Top371
Node: Preface3095
Node: Audience3278
Node: Overview3397
Node: Conventions3567
Node: Acknowledgements4487
Node: Introduction4603
Node: Documentation4900
Node: Installing Ruby5305
Node: Package Management Systems6218
Node: Homebrew (OS X)7043
Node: Installers7469
Node: ruby-build8065
Node: ruby-install8618
Node: Managers9233
Node: chruby9630
Node: rbenv9889
Node: RVM (``Ruby Version Manager'')10434
Node: uru10832
Node: Building From Source11125
Node: Releases Page12137
Node: Branches Page13237
Node: Issue Tracking15037
Node: Developing Ruby15521
Ref: subversion16271
Ref: MainRubyRepo17423
Ref: PatchByPatch17751
Node: Getting Started18548
Node: Try Ruby!18936
Node: Official FAQ19266
Node: FAQ Iterators20343
Node: FAQ Syntax24282
Ref: immediate value25427
Ref: nil vs false26062
Ref: empty string26676
Ref: symbol object27029
Ref: value of symbol28167
Ref: loop29045
Ref: post-test loop29271
Ref: hash literal29697
Ref: pos val29979
Ref: \1 and \\130355
Ref: 2 dots vs 3 dots30763
Ref: or and31001
Ref: function pointers31803
Ref: load vs require32125
Ref: exception handling32480
Node: FAQ Methods33477
Node: FAQ Classes and Modules35150
Node: FAQ Built-In Libraries36336
Node: FAQ Extension Library38314
Node: FAQ Other Features38993
Node: Ruby Koans39543
Node: Why’s (Poignant) Guide to Ruby39947
Node: Ruby in Twenty Minutes40421
Node: Interactive Ruby41094
Node: Defining Methods42048
Node: Altering Classes47552
Node: Large Class Definition48888
Ref: ri20min-rb49292
Ref: MegaGreeter---Initialize-Method50101
Ref: MegaGreeter---say-hi-Method50823
Ref: MegaGreeter---say-bye-Method53040
Ref: MegaGreeter---Main-Script53988
Node: Run MegaGreeter54520
Node: Ruby from Other Languages55046
Node: To Ruby From C and C++55764
Node: To Ruby From Java63293
Node: To Ruby From Perl65860
Node: To Ruby From PHP68819
Node: To Ruby From Python70996
Node: Important Language Features75131
Node: Pointers on Iteration75885
Node: Everything has a value76681
Node: Symbols are not lightweight Strings77161
Node: Everything is an Object78606
Node: Variable Constants79167
Node: Naming conventions79560
Node: Keyword arguments80256
Node: The universal truth80806
Node: Access modifiers are Methods81558
Node: Method access82561
Node: Classes are open84175
Node: Funny method names84890
Node: Singleton methods85692
Node: Missing methods86319
Node: Message passing --- not function calls87398
Node: Blocks are Objects87819
Node: Operators are syntactic sugar88730
Node: Learning Ruby89743
Node: Ruby Essentials90111
Node: Learn to Program90342
Node: Manuals90721
Node: Ruby User's Guide90913
Node: What Is Ruby?91364
Node: Simple Examples92353
Ref: fact-rb92744
Node: Programming Ruby95012
Node: Reference Documentation99442
Node: Editors and IDEs99614
Node: Further Reading99780
Node: The Makefile99912
Ref: Makefile100065
Node: Makefile Variable Definitions100774
Ref: Makefile---Variable-Definitions100952
Node: Makefile Default Rule101120
Ref: Makefile---Default-Rule101670
Node: Makefile TWJR Rules101909
Ref: Makefile---TWJR-Rules102068
Node: Makefile Clean Rules102699
Ref: Makefile---Clean-Rules102830
Node: Code Chunk Summaries103287
Node: File Definitions103672
Node: Code Chunk Definitions104020
Node: Code Chunk References104963
Node: Bibliography106127
Node: Concept Index106258

End Tag Table
